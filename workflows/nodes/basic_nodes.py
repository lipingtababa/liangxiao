"""Basic workflow node implementations.

These are stub implementations that will be replaced with actual agent calls
in future stories. For now, they provide the workflow structure and basic
state transitions.
"""

import asyncio
from datetime import datetime
from typing import Dict, Any

from core.logging import get_logger
from workflows.workflow_state import (
    IssueWorkflowState,
    WorkflowStatus,
    update_state_timestamp,
    add_error,
    add_warning
)

logger = get_logger(__name__)


async def receive_issue_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Receive and validate issue for processing.
    
    This node:
    - Validates the issue data
    - Sets up initial workflow state
    - Prepares for analysis
    """
    logger.info(
        f"Receiving issue #{state['issue_number']} - {state['issue_title']} "
        f"in {state['repository']}"
    )
    
    # Validate required fields
    required_fields = ['issue_number', 'issue_title', 'repository']
    for field in required_fields:
        if not state.get(field):
            error_msg = f"Missing required field: {field}"
            logger.error(error_msg)
            state = add_error(state, error_msg)
            state["status"] = WorkflowStatus.FAILED
            state["should_continue"] = False
            return update_state_timestamp(state)
    
    # Set initial status
    state["status"] = WorkflowStatus.RECEIVED
    state["should_continue"] = True
    
    # Initialize collections if not present
    if "artifacts" not in state:
        state["artifacts"] = []
    if "test_results" not in state:
        state["test_results"] = []
    if "review_feedback" not in state:
        state["review_feedback"] = []
    
    logger.info(f"Issue #{state['issue_number']} ready for processing")
    return update_state_timestamp(state)


async def analyze_issue_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Analyze issue requirements using PM Agent.
    
    This node delegates to the PM Agent for intelligent issue analysis.
    Falls back to basic analysis if PM Agent is unavailable.
    """
    try:
        # Try to use PM Agent
        from workflows.nodes.pm_nodes import pm_analyze_issue_node
        return await pm_analyze_issue_node(state)
    except ImportError:
        logger.warning("PM Agent not available, using basic analysis")
        return await _basic_analyze_issue_node(state)
    except Exception as e:
        logger.error(f"PM Agent analysis failed: {e}, falling back to basic analysis")
        return await _basic_analyze_issue_node(state)


async def _basic_analyze_issue_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Basic issue analysis fallback (original stub implementation).
    """
    logger.info(f"Basic analysis for issue #{state['issue_number']}")
    
    state["status"] = WorkflowStatus.ANALYZING
    state["agent_interactions"] = state.get("agent_interactions", 0) + 1
    
    # Simulate analysis time
    await asyncio.sleep(0.1)
    
    # Stub analysis based on issue content
    issue_body = state.get("issue_body", "").lower()
    issue_title = state.get("issue_title", "").lower()
    
    # Simple heuristics for analysis
    complexity = "simple"
    if any(word in issue_body + issue_title for word in ["complex", "major", "refactor", "architecture"]):
        complexity = "complex"
    elif any(word in issue_body + issue_title for word in ["bug", "fix", "issue", "problem"]):
        complexity = "medium"
    
    analysis_type = "enhancement"
    if any(word in issue_body + issue_title for word in ["bug", "error", "broken", "fail"]):
        analysis_type = "bug_fix"
    elif any(word in issue_body + issue_title for word in ["test", "testing"]):
        analysis_type = "testing"
    elif any(word in issue_body + issue_title for word in ["doc", "documentation"]):
        analysis_type = "documentation"
    
    # Create analysis result (compatible with PM Agent format)
    state["analysis"] = {
        "issue_type": analysis_type,
        "summary": f"Basic analysis of {analysis_type} issue",
        "complexity": complexity,
        "estimated_effort": "1-3 hours" if complexity == "simple" else "4-8 hours",
        "risks": [],
        "assumptions": ["Basic heuristic analysis"],
        "questions": [],
        "key_requirements": [
            "Fix the reported issue",
            "Ensure no regression",
            "Add appropriate tests"
        ],
        "affected_areas": [],
        "confidence_score": 0.6,
        "analysis_notes": "Generated by basic fallback analysis",
        "analyzed_at": datetime.utcnow().isoformat()
    }
    
    if complexity == "complex":
        state["max_iterations"] = 5  # More iterations for complex issues
    
    logger.info(
        f"Issue #{state['issue_number']} analyzed (basic): "
        f"type={analysis_type}, complexity={complexity}"
    )
    
    return update_state_timestamp(state)


async def plan_tasks_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Create implementation task plan using PM Agent.
    
    This node delegates to the PM Agent for intelligent task breakdown.
    Falls back to basic planning if PM Agent is unavailable.
    """
    try:
        # Try to use PM Agent
        from workflows.nodes.pm_nodes import pm_plan_tasks_node
        return await pm_plan_tasks_node(state)
    except ImportError:
        logger.warning("PM Agent not available, using basic task planning")
        return await _basic_plan_tasks_node(state)
    except Exception as e:
        logger.error(f"PM Agent task planning failed: {e}, falling back to basic planning")
        return await _basic_plan_tasks_node(state)


async def _basic_plan_tasks_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Basic task planning fallback (original stub implementation).
    """
    logger.info(f"Basic task planning for issue #{state['issue_number']}")
    
    state["status"] = WorkflowStatus.PLANNING
    state["agent_interactions"] = state.get("agent_interactions", 0) + 1
    
    # Simulate planning time
    await asyncio.sleep(0.1)
    
    analysis = state.get("analysis", {})
    issue_type = analysis.get("issue_type", "enhancement")
    complexity = analysis.get("complexity", "medium")
    
    # Create task plan based on analysis
    tasks = []
    
    # Always start with investigation
    tasks.append({
        "id": "task-1",
        "title": "Investigate issue",
        "description": f"Investigate and understand the issue: {state['issue_title']}",
        "task_type": "analysis",
        "assigned_agent": "analyst",
        "estimated_hours": 0.5,
        "estimated_complexity": "simple",
        "priority": "high",
        "status": "pending",
        "dependencies": [],
        "acceptance_criteria": [
            "Root cause identified",
            "Requirements clearly understood",
            "Solution approach documented"
        ]
    })
    
    # Main implementation task
    if issue_type == "bug_fix":
        tasks.append({
            "id": "task-2",
            "title": "Fix identified bug",
            "description": "Fix the identified bug based on investigation results",
            "task_type": "implementation",
            "assigned_agent": "developer",
            "estimated_hours": 2.0 if complexity == "simple" else 4.0,
            "estimated_complexity": complexity,
            "priority": "high",
            "status": "pending",
            "dependencies": ["task-1"],
            "acceptance_criteria": [
                "Bug is fixed",
                "No regression in existing functionality",
                "Code follows project standards"
            ]
        })
    else:
        tasks.append({
            "id": "task-2",
            "title": "Implement feature",
            "description": "Implement the requested feature based on requirements",
            "task_type": "implementation", 
            "assigned_agent": "developer",
            "estimated_hours": 3.0 if complexity == "simple" else 6.0,
            "estimated_complexity": complexity,
            "priority": "medium",
            "status": "pending",
            "dependencies": ["task-1"],
            "acceptance_criteria": [
                "Feature implemented as specified",
                "Code is well-structured and documented",
                "Integration with existing code is seamless"
            ]
        })
    
    # Add testing task
    tasks.append({
        "id": "task-3",
        "title": "Create and run tests",
        "description": "Create comprehensive tests for the implementation",
        "task_type": "testing",
        "assigned_agent": "tester",
        "estimated_hours": 1.0,
        "estimated_complexity": "simple",
        "priority": "high",
        "status": "pending",
        "dependencies": ["task-2"],
        "acceptance_criteria": [
            "Unit tests created and passing",
            "Integration tests added if needed",
            "Test coverage meets project standards"
        ]
    })
    
    # Add documentation task if needed
    if complexity != "simple" or issue_type == "documentation":
        tasks.append({
            "id": "task-4",
            "title": "Update documentation",
            "description": "Update documentation to reflect the changes",
            "task_type": "documentation",
            "assigned_agent": "developer",
            "estimated_hours": 0.5,
            "estimated_complexity": "simple",
            "priority": "low",
            "status": "pending",
            "dependencies": ["task-2"],
            "acceptance_criteria": [
                "Documentation updated with changes",
                "Examples provided where appropriate",
                "Documentation is clear and accurate"
            ]
        })
    
    # Calculate execution order and totals
    execution_order = [task["id"] for task in tasks]
    total_estimated_hours = sum(task["estimated_hours"] for task in tasks)
    
    # Store in state
    state["tasks"] = tasks
    state["task_execution_order"] = execution_order
    state["total_estimated_hours"] = total_estimated_hours
    state["current_task"] = tasks[0] if tasks else None
    state["current_task_index"] = 0
    state["completed_task_ids"] = []
    
    logger.info(
        f"Created {len(tasks)} tasks for issue #{state['issue_number']} "
        f"({total_estimated_hours:.1f}h total)"
    )
    
    return update_state_timestamp(state)


async def execute_task_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Execute current task (stub - will call agent pairs).
    
    This node will:
    - Execute the current task using appropriate agent pair
    - Generate artifacts (code, tests, docs)
    - Handle task-specific logic and requirements
    """
    current_task = state.get("current_task")
    if not current_task:
        logger.warning(f"No current task for issue #{state['issue_number']}")
        state = add_warning(state, "No current task to execute")
        state["should_continue"] = False
        return update_state_timestamp(state)
    
    logger.info(
        f"Executing task {current_task['id']} for issue #{state['issue_number']}: "
        f"{current_task['description']}"
    )
    
    state["status"] = WorkflowStatus.DEVELOPING
    state["current_iteration"] = state.get("current_iteration", 0) + 1
    state["agent_interactions"] = state.get("agent_interactions", 0) + 1
    
    # Simulate task execution time
    await asyncio.sleep(0.2)
    
    task_type = current_task.get("type", "implementation")
    
    # Generate different artifacts based on task type
    if task_type == "investigation":
        artifact = {
            "type": "investigation_report",
            "task_id": current_task["id"],
            "content": {
                "findings": [
                    "Located the issue in the codebase",
                    "Identified root cause",
                    "Found related code sections"
                ],
                "files_involved": ["src/main.py", "src/utils.py"],
                "proposed_solution": "Update the logic in main.py to handle edge case"
            },
            "created_at": datetime.utcnow().isoformat(),
            "iteration": state["current_iteration"]
        }
    
    elif task_type == "implementation":
        artifact = {
            "type": "code",
            "task_id": current_task["id"],
            "content": {
                "files_changed": ["src/main.py"],
                "changes": [
                    {
                        "file": "src/main.py",
                        "action": "modified",
                        "lines_changed": 15,
                        "description": "Fixed the bug by adding null check"
                    }
                ],
                "code_snippet": "# Fixed the bug\nif value is not None:\n    return process_value(value)\nreturn default_value"
            },
            "created_at": datetime.utcnow().isoformat(),
            "iteration": state["current_iteration"]
        }
    
    elif task_type == "testing":
        artifact = {
            "type": "tests",
            "task_id": current_task["id"],
            "content": {
                "test_files": ["tests/test_main.py"],
                "tests_added": 3,
                "test_coverage": "85%",
                "test_results": "All tests passing"
            },
            "created_at": datetime.utcnow().isoformat(),
            "iteration": state["current_iteration"]
        }
    
    else:  # documentation or other
        artifact = {
            "type": "documentation",
            "task_id": current_task["id"],
            "content": {
                "files_updated": ["README.md", "docs/api.md"],
                "sections_added": ["Bug Fix Notes", "Usage Examples"],
                "description": "Updated documentation to reflect the changes"
            },
            "created_at": datetime.utcnow().isoformat(),
            "iteration": state["current_iteration"]
        }
    
    # Add artifact to state
    if "artifacts" not in state:
        state["artifacts"] = []
    state["artifacts"].append(artifact)
    
    # Update task status
    current_task["status"] = "completed"
    current_task["completed_at"] = datetime.utcnow().isoformat()
    
    # Add some simulated token usage
    state["tokens_used"] = state.get("tokens_used", 0) + 1500
    
    logger.info(
        f"Task {current_task['id']} completed for issue #{state['issue_number']}"
    )
    
    return update_state_timestamp(state)


async def review_task_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Review task results using Navigator Agent with progressive leniency.
    
    This node uses the Navigator Agent to:
    - Review the generated artifacts with intelligent analysis
    - Provide specific, actionable feedback
    - Make informed decisions about quality and completeness
    - Implement progressive leniency to prevent infinite loops
    - Catch disasters like PR #23 (where entire files were deleted)
    """
    logger.info(f"Reviewing task for issue #{state['issue_number']} using Navigator Agent")
    
    # Import here to avoid circular imports
    from agents.navigator import NavigatorAgent, ReviewDecision
    
    state["status"] = WorkflowStatus.REVIEWING
    state["agent_interactions"] = state.get("agent_interactions", 0) + 1
    
    current_task = state.get("current_task")
    artifacts = state.get("artifacts", [])
    current_iteration = state.get("current_iteration", 0)
    max_iterations = state.get("max_iterations", 3)
    
    if not artifacts and not current_task:
        logger.warning(f"No artifacts or task to review for issue #{state['issue_number']}")
        state = add_warning(state, "No artifacts or task found for review")
        state["next_step"] = "error"
        return update_state_timestamp(state)
    
    try:
        # Determine review specialty based on task type
        task_type = current_task.get("type", "implementation") if current_task else "implementation"
        if task_type in ["testing", "test"]:
            specialty = "test_review"
        elif task_type in ["investigation", "analysis", "requirements"]:
            specialty = "requirements_review"
        else:
            specialty = "code_review"  # Default for implementation, bug fixes, etc.
        
        # Create Navigator Agent with appropriate specialty
        navigator = NavigatorAgent(specialty=specialty, base_strictness=1.0)
        
        # Prepare work output for review
        work_output = {
            "artifacts": artifacts,
            "task_id": current_task.get("id") if current_task else None
        }
        
        # Prepare context for review
        context = {
            "issue": {
                "number": state.get("issue_number"),
                "title": state.get("issue_title"),
                "body": state.get("issue_body")
            },
            "repository": state.get("repository"),
            "max_iterations": max_iterations,
            "previous_feedback": state.get("review_feedback", [])
        }
        
        # Get structured feedback from Navigator
        logger.info(f"Running {specialty} review for iteration {current_iteration}")
        feedback = await navigator.review(
            task=current_task or {},
            work_output=work_output,
            context=context,
            iteration_number=current_iteration
        )
        
        # Convert Navigator feedback to workflow format
        review_feedback = {
            "task_id": current_task.get("id") if current_task else "unknown",
            "reviewer": "navigator_agent",
            "specialty": specialty,
            "decision": feedback.decision.value,
            "score": feedback.quality_score / 10.0,  # Convert to 0-1 scale
            "quality_score": feedback.quality_score,
            "completeness_score": feedback.completeness_score,
            "correctness_score": feedback.correctness_score,
            "overall_assessment": feedback.overall_assessment,
            "issues": [
                {
                    "severity": issue.severity,
                    "category": issue.category,
                    "location": issue.location,
                    "description": issue.description,
                    "suggestion": issue.suggestion
                }
                for issue in feedback.issues
            ],
            "required_changes": feedback.required_changes,
            "suggestions": feedback.suggestions,
            "positive_aspects": feedback.positive_aspects,
            "reasoning": feedback.reasoning,
            "iteration": current_iteration,
            "adjusted_strictness": feedback.adjusted_strictness,
            "needs_revision": feedback.decision == ReviewDecision.NEEDS_CHANGES,
            "reviewed_at": feedback.reviewed_at
        }
        
        # Add review feedback to state
        if "review_feedback" not in state:
            state["review_feedback"] = []
        state["review_feedback"].append(review_feedback)
        
        # Log detailed review results
        logger.info(
            f"Navigator review completed: {feedback.decision.value}, "
            f"quality={feedback.quality_score}/10, "
            f"issues={len(feedback.issues)}, "
            f"strictness={feedback.adjusted_strictness:.2f}"
        )
        
        # Log specific issues found
        if feedback.issues:
            for issue in feedback.issues:
                logger.info(
                    f"Issue found - {issue.severity} {issue.category} at {issue.location}: {issue.description}"
                )
        
        # Decide next step based on Navigator's decision and iteration limits
        if feedback.decision == ReviewDecision.APPROVED:
            state["next_step"] = "continue"
            state["status"] = WorkflowStatus.REVIEWED
            logger.info(f"Task approved by Navigator for issue #{state['issue_number']}")
        
        elif feedback.decision == ReviewDecision.NEEDS_CHANGES:
            if current_iteration < max_iterations:
                state["next_step"] = "iterate"
                state["status"] = WorkflowStatus.NEEDS_REVISION
                
                # Add iteration guidance to help the next agent
                guidance = navigator.provide_iteration_guidance(feedback, current_iteration + 1)
                state["iteration_guidance"] = guidance
                
                logger.info(
                    f"Task needs revision for issue #{state['issue_number']} "
                    f"(iteration {current_iteration}/{max_iterations})"
                )
                logger.info(f"Guidance for next iteration: {guidance}")
            else:
                # Max iterations reached, but accept with warnings
                state["next_step"] = "continue"
                state["status"] = WorkflowStatus.REVIEWED
                state = add_warning(
                    state, 
                    f"Max iterations reached ({max_iterations}), accepting with issues"
                )
                logger.warning(
                    f"Max iterations reached for issue #{state['issue_number']}, "
                    f"accepting work with {len(feedback.issues)} remaining issues"
                )
        
        else:  # REJECTED
            state["next_step"] = "error"
            state["status"] = WorkflowStatus.FAILED
            state = add_error(state, f"Navigator rejected the work: {feedback.reasoning}")
            logger.error(f"Task rejected by Navigator for issue #{state['issue_number']}")
        
    except Exception as e:
        logger.error(f"Navigator review failed for issue #{state['issue_number']}: {e}")
        
        # Create fallback review feedback
        review_feedback = {
            "task_id": current_task.get("id") if current_task else "unknown",
            "reviewer": "navigator_agent_error",
            "decision": "error",
            "score": 0.0,
            "error": str(e),
            "iteration": current_iteration,
            "needs_revision": True,
            "reviewed_at": datetime.utcnow().isoformat()
        }
        
        if "review_feedback" not in state:
            state["review_feedback"] = []
        state["review_feedback"].append(review_feedback)
        
        # Continue with error handling
        state["next_step"] = "error"
        state = add_error(state, f"Navigator review failed: {e}")
    
    return update_state_timestamp(state)


async def test_solution_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Test the implemented solution (stub - will be Tester agent).
    
    This node will:
    - Run automated tests
    - Verify the solution works
    - Check for regressions
    - Generate test reports
    """
    logger.info(f"Testing solution for issue #{state['issue_number']}")
    
    state["status"] = WorkflowStatus.TESTING
    state["agent_interactions"] = state.get("agent_interactions", 0) + 1
    
    # Simulate testing time
    await asyncio.sleep(0.15)
    
    # Simulate test execution
    test_result = {
        "test_suite": "automated_tests",
        "total_tests": 25,
        "passed": 24,
        "failed": 1,
        "skipped": 0,
        "coverage": "87%",
        "execution_time": "2.3 seconds",
        "test_files": ["tests/test_main.py", "tests/test_utils.py"],
        "failed_tests": [
            {
                "name": "test_edge_case_handling",
                "error": "AssertionError: Expected None, got ''",
                "file": "tests/test_main.py",
                "line": 45
            }
        ] if state['issue_number'] % 4 == 0 else [],  # Simulate occasional test failures
        "tested_at": datetime.utcnow().isoformat()
    }
    
    # Add test results to state
    if "test_results" not in state:
        state["test_results"] = []
    state["test_results"].append(test_result)
    
    # Check if tests passed
    if test_result["failed"] == 0:
        logger.info(f"All tests passed for issue #{state['issue_number']}")
        state["next_step"] = "continue"
    else:
        logger.warning(
            f"Tests failed for issue #{state['issue_number']}: "
            f"{test_result['failed']} failures"
        )
        state = add_warning(state, f"Test failures: {test_result['failed']}")
        
        # If we still have iterations left, try to fix
        if state.get("current_iteration", 0) < state.get("max_iterations", 3):
            state["next_step"] = "iterate"
            state["status"] = WorkflowStatus.NEEDS_REVISION
        else:
            state["next_step"] = "error"
    
    return update_state_timestamp(state)


async def create_pr_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Create pull request using GitHub CLI integration.
    
    This node will:
    - Create a new branch using GitHub service
    - Create pull request with comprehensive description
    - Comment on the original issue
    - Add appropriate labels
    """
    logger.info(f"Creating PR for issue #{state['issue_number']}")
    
    state["status"] = WorkflowStatus.PR_CREATING
    state["agent_interactions"] = state.get("agent_interactions", 0) + 1
    
    try:
        # Import GitHub integration here to avoid circular imports
        from workflows.github_integration import (
            create_pull_request_from_state,
            add_issue_labels_from_state
        )
        
        # Create pull request using GitHub service
        pr_success = await create_pull_request_from_state(state)
        
        if pr_success:
            logger.info(f"Successfully created PR for issue #{state['issue_number']}")
            
            # Add labels to the issue
            await add_issue_labels_from_state(state)
            
            # Update final status
            state["status"] = WorkflowStatus.COMPLETED
            state["completed_at"] = datetime.utcnow()
            state["should_continue"] = False
            
            logger.info(
                f"PR workflow completed for issue #{state['issue_number']}: "
                f"{state.get('pr_url', 'URL not available')}"
            )
        else:
            logger.error(f"Failed to create PR for issue #{state['issue_number']}")
            state["status"] = WorkflowStatus.FAILED
            state["should_continue"] = False
            state = add_error(state, "Failed to create pull request")
            
    except Exception as e:
        logger.error(f"Error creating PR for issue #{state['issue_number']}: {e}")
        state["status"] = WorkflowStatus.FAILED
        state["should_continue"] = False
        state = add_error(state, f"PR creation failed: {e}")
        
        # Set fallback values for debugging
        if "branch_name" not in state:
            state["branch_name"] = f"fix/issue-{state['issue_number']}"
    
    return update_state_timestamp(state)


async def handle_error_node(state: IssueWorkflowState) -> IssueWorkflowState:
    """
    Handle workflow errors and failures.
    
    This node will:
    - Log error details
    - Attempt recovery if possible
    - Set final failure state
    - Clean up resources
    """
    logger.error(f"Handling error for issue #{state['issue_number']}")
    
    state["status"] = WorkflowStatus.FAILED
    state["completed_at"] = datetime.utcnow()
    state["should_continue"] = False
    
    # Log error summary
    errors = state.get("errors", [])
    warnings = state.get("warnings", [])
    
    error_summary = f"Workflow failed for issue #{state['issue_number']}"
    if errors:
        error_summary += f" - Errors: {len(errors)}"
    if warnings:
        error_summary += f" - Warnings: {len(warnings)}"
    
    logger.error(error_summary)
    
    # Add final error if none exists
    if not errors:
        state = add_error(state, "Workflow failed with unknown error")
    
    return update_state_timestamp(state)