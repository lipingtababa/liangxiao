"""Developer Agent data models and structures.

This module defines the data structures used by the Developer Agent for
code generation, artifact management, and integration with the Navigator.
"""

from typing import List, Optional, Dict, Any, Union, Literal
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field, validator


class ArtifactType(str, Enum):
    """Types of artifacts the Developer Agent can create."""
    CODE = "code"
    TEST = "test"
    DOCUMENTATION = "documentation"
    CONFIGURATION = "configuration"
    MIGRATION = "migration"
    SCRIPT = "script"


class ModificationType(str, Enum):
    """Types of file modifications."""
    CREATE = "create"
    UPDATE = "update"
    DELETE = "delete"
    RENAME = "rename"


class ImplementationStatus(str, Enum):
    """Status of implementation work."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    NEEDS_REVIEW = "needs_review"


class ProgrammingLanguage(str, Enum):
    """Supported programming languages."""
    PYTHON = "python"
    JAVASCRIPT = "javascript"
    TYPESCRIPT = "typescript"
    JAVA = "java"
    GO = "go"
    RUST = "rust"
    CPP = "cpp"
    CSHARP = "csharp"
    SHELL = "shell"
    SQL = "sql"
    YAML = "yaml"
    JSON = "json"
    MARKDOWN = "markdown"
    HTML = "html"
    CSS = "css"


class CodeArtifact(BaseModel):
    """
    Represents a single code artifact generated by the Developer Agent.
    
    This includes complete file contents, metadata, and context needed
    for integration with other agents and the GitHub service.
    """
    
    # Core artifact information
    type: ArtifactType = Field(
        description="Type of artifact (code, test, documentation, etc.)"
    )
    path: str = Field(
        description="Relative file path where this artifact should be created/updated"
    )
    content: str = Field(
        description="Complete file content for the artifact"
    )
    
    # Language and technical details
    language: Optional[ProgrammingLanguage] = Field(
        None,
        description="Programming language of the artifact"
    )
    framework: Optional[str] = Field(
        None,
        description="Framework or library used (e.g., 'react', 'django', 'express')"
    )
    
    # Metadata and context
    description: str = Field(
        description="Human-readable description of what this artifact does"
    )
    modification_type: ModificationType = Field(
        description="Whether this creates, updates, or deletes a file"
    )
    
    # Requirements traceability
    requirements_addressed: List[str] = Field(
        default=[],
        description="List of requirement IDs or descriptions this artifact addresses"
    )
    dependencies: List[str] = Field(
        default=[],
        description="Files or modules this artifact depends on"
    )
    
    # Quality and safety information
    safety_checks: List[str] = Field(
        default=[],
        description="Safety checks performed (e.g., 'read existing file first')"
    )
    disaster_prevention_notes: List[str] = Field(
        default=[],
        description="Notes about how this prevents disasters like PR #23"
    )
    
    # Integration information
    existing_content_preserved: Optional[str] = Field(
        None,
        description="Critical existing content that must be preserved"
    )
    backup_path: Optional[str] = Field(
        None,
        description="Path where backup of original file is stored"
    )
    
    # Validation and testing
    syntax_validated: bool = Field(
        default=False,
        description="Whether syntax validation was performed"
    )
    test_coverage_notes: List[str] = Field(
        default=[],
        description="Notes about test coverage for this artifact"
    )
    
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this artifact was created"
    )
    
    @validator('path')
    def validate_path(cls, v):
        """Validate that path is not empty and follows conventions."""
        if not v or not v.strip():
            raise ValueError("Path cannot be empty")
        
        # Normalize path separators
        v = v.replace('\\', '/')
        
        # Ensure no dangerous path patterns
        if '..' in v or v.startswith('/'):
            raise ValueError("Path cannot contain '..' or start with '/'")
            
        return v.strip()
    
    @validator('content')
    def validate_content(cls, v):
        """Validate that content is not None."""
        if v is None:
            raise ValueError("Content cannot be None")
        return v
    
    def get_file_extension(self) -> str:
        """Get file extension from path."""
        return self.path.split('.')[-1].lower() if '.' in self.path else ""
    
    def get_estimated_lines(self) -> int:
        """Get estimated number of lines in the content."""
        return len(self.content.split('\n')) if self.content else 0
    
    def is_safe_to_create(self) -> bool:
        """Check if this artifact is safe to create based on safety checks."""
        required_safety_checks = [
            "read_existing_file_first",
            "validate_modification_scope",
            "preserve_critical_content"
        ]
        
        # For updates, ensure we performed critical safety checks
        if self.modification_type == ModificationType.UPDATE:
            return any(check in self.safety_checks for check in required_safety_checks)
        
        # For new files, basic validation is sufficient
        return len(self.safety_checks) > 0


class FileModification(BaseModel):
    """
    Represents a specific modification to be made to a file.
    
    This provides granular control over file changes and helps prevent
    disasters by being explicit about what changes vs what preserves.
    """
    
    file_path: str = Field(
        description="Path to the file being modified"
    )
    modification_type: ModificationType = Field(
        description="Type of modification being performed"
    )
    
    # Content changes
    original_content: Optional[str] = Field(
        None,
        description="Original file content (read from GitHub)"
    )
    new_content: Optional[str] = Field(
        None,
        description="New complete file content"
    )
    
    # Targeted changes (for surgical updates)
    target_section: Optional[str] = Field(
        None,
        description="Specific section being modified"
    )
    replacement_section: Optional[str] = Field(
        None,
        description="What to replace the target section with"
    )
    
    # Safety and validation
    content_validation: Dict[str, bool] = Field(
        default_factory=dict,
        description="Validation checks performed (e.g., 'syntax_valid': True)"
    )
    preservation_notes: List[str] = Field(
        default=[],
        description="Notes about what existing content is preserved"
    )
    
    # Context and reasoning
    reason: str = Field(
        description="Why this modification is being made"
    )
    requirements_link: List[str] = Field(
        default=[],
        description="Requirements that led to this modification"
    )
    
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this modification was planned"
    )
    
    def get_change_summary(self) -> str:
        """Get a summary of what this modification changes."""
        if self.modification_type == ModificationType.CREATE:
            return f"Create new file: {self.file_path}"
        elif self.modification_type == ModificationType.UPDATE:
            if self.target_section:
                return f"Update section in {self.file_path}: {self.target_section[:100]}..."
            else:
                return f"Update entire file: {self.file_path}"
        elif self.modification_type == ModificationType.DELETE:
            return f"Delete file: {self.file_path}"
        else:
            return f"{self.modification_type} file: {self.file_path}"


class CodeSolution(BaseModel):
    """
    Complete code solution for a task or set of requirements.
    
    This represents the overall solution architecture and coordinates
    multiple artifacts that work together.
    """
    
    # Solution metadata
    solution_id: str = Field(
        description="Unique identifier for this solution"
    )
    description: str = Field(
        description="High-level description of what this solution does"
    )
    
    # Requirements and context
    requirements_addressed: List[str] = Field(
        description="List of requirements this solution addresses"
    )
    issue_number: Optional[int] = Field(
        None,
        description="GitHub issue number this solution addresses"
    )
    
    # Technical implementation
    primary_language: ProgrammingLanguage = Field(
        description="Primary programming language used"
    )
    architecture_pattern: Optional[str] = Field(
        None,
        description="Architecture pattern used (e.g., 'MVC', 'microservices', 'layered')"
    )
    
    # Artifacts and files
    artifacts: List[CodeArtifact] = Field(
        description="List of code artifacts that make up this solution"
    )
    file_modifications: List[FileModification] = Field(
        default=[],
        description="Specific file modifications to be performed"
    )
    
    # Dependencies and integration
    external_dependencies: List[str] = Field(
        default=[],
        description="External libraries or services this solution depends on"
    )
    internal_dependencies: List[str] = Field(
        default=[],
        description="Internal modules or components this solution depends on"
    )
    
    # Quality and testing
    test_strategy: str = Field(
        description="Testing strategy for this solution"
    )
    quality_checks: List[str] = Field(
        default=[],
        description="Quality checks that should be performed"
    )
    
    # Implementation guidance
    implementation_order: List[str] = Field(
        default=[],
        description="Recommended order to implement artifacts"
    )
    deployment_notes: List[str] = Field(
        default=[],
        description="Notes about deploying this solution"
    )
    
    # Safety and disaster prevention
    disaster_prevention_measures: List[str] = Field(
        default=[],
        description="Measures taken to prevent implementation disasters"
    )
    rollback_plan: str = Field(
        description="How to rollback this solution if problems occur"
    )
    
    # Metrics and estimation
    estimated_complexity: Literal["low", "medium", "high", "very_high"] = Field(
        description="Estimated complexity of implementing this solution"
    )
    estimated_time_hours: Optional[int] = Field(
        None,
        description="Estimated time to implement in hours"
    )
    
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this solution was created"
    )
    
    def get_total_artifacts(self) -> int:
        """Get total number of artifacts in this solution."""
        return len(self.artifacts)
    
    def get_artifacts_by_type(self, artifact_type: ArtifactType) -> List[CodeArtifact]:
        """Get all artifacts of a specific type."""
        return [artifact for artifact in self.artifacts if artifact.type == artifact_type]
    
    def get_new_files(self) -> List[CodeArtifact]:
        """Get artifacts that create new files."""
        return [
            artifact for artifact in self.artifacts 
            if artifact.modification_type == ModificationType.CREATE
        ]
    
    def get_modified_files(self) -> List[CodeArtifact]:
        """Get artifacts that modify existing files."""
        return [
            artifact for artifact in self.artifacts 
            if artifact.modification_type == ModificationType.UPDATE
        ]
    
    def validate_solution_completeness(self) -> List[str]:
        """Validate that the solution is complete and consistent."""
        issues = []
        
        # Check that we have artifacts
        if not self.artifacts:
            issues.append("Solution has no artifacts")
        
        # Check that requirements are addressed
        if not self.requirements_addressed:
            issues.append("No requirements specified")
        
        # Check for circular dependencies
        artifact_paths = set(artifact.path for artifact in self.artifacts)
        for artifact in self.artifacts:
            for dep in artifact.dependencies:
                if dep not in artifact_paths:
                    issues.append(f"Artifact {artifact.path} depends on missing file {dep}")
        
        # Check implementation order
        if self.implementation_order:
            order_paths = set(self.implementation_order)
            artifact_paths = set(artifact.path for artifact in self.artifacts)
            missing_from_order = artifact_paths - order_paths
            if missing_from_order:
                issues.append(f"Implementation order missing: {', '.join(missing_from_order)}")
        
        return issues


class ImplementationResult(BaseModel):
    """
    Result of implementing a code solution.
    
    This captures the outcome of the Developer Agent's work and provides
    structured feedback for the Navigator Agent.
    """
    
    # Status and outcome
    status: ImplementationStatus = Field(
        description="Status of the implementation"
    )
    success: bool = Field(
        description="Whether implementation was successful"
    )
    
    # Solution and artifacts
    solution: CodeSolution = Field(
        description="The solution that was implemented"
    )
    artifacts_created: List[CodeArtifact] = Field(
        description="Artifacts that were successfully created"
    )
    
    # Execution details
    execution_time_seconds: float = Field(
        description="Time taken to generate the implementation"
    )
    tokens_used: Optional[int] = Field(
        None,
        description="Number of LLM tokens used"
    )
    
    # Quality and validation
    syntax_validation_results: Dict[str, bool] = Field(
        default_factory=dict,
        description="Results of syntax validation for each file"
    )
    safety_checks_performed: List[str] = Field(
        default=[],
        description="Safety checks that were performed"
    )
    
    # Issues and warnings
    warnings: List[str] = Field(
        default=[],
        description="Warnings about the implementation"
    )
    errors: List[str] = Field(
        default=[],
        description="Errors encountered during implementation"
    )
    
    # Integration information
    files_read_from_repo: List[str] = Field(
        default=[],
        description="Files that were read from the repository"
    )
    github_operations_performed: List[str] = Field(
        default=[],
        description="GitHub operations that were performed"
    )
    
    # Summary and documentation
    summary: str = Field(
        description="Summary of what was implemented"
    )
    implementation_notes: List[str] = Field(
        default=[],
        description="Notes about the implementation process"
    )
    
    # Navigator feedback integration
    addressed_previous_feedback: List[str] = Field(
        default=[],
        description="Previous Navigator feedback that was addressed"
    )
    iteration_number: int = Field(
        default=1,
        description="Which iteration of the task this represents"
    )
    
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this result was created"
    )
    
    def get_success_rate(self) -> float:
        """Calculate success rate based on artifacts created vs planned."""
        planned = len(self.solution.artifacts)
        created = len(self.artifacts_created)
        return (created / planned) if planned > 0 else 0.0
    
    def get_quality_score(self) -> float:
        """Calculate overall quality score based on validation results."""
        if not self.syntax_validation_results:
            return 0.0
        
        valid_count = sum(1 for result in self.syntax_validation_results.values() if result)
        total_count = len(self.syntax_validation_results)
        
        base_score = (valid_count / total_count) if total_count > 0 else 0.0
        
        # Penalize for errors and warnings
        error_penalty = len(self.errors) * 0.1
        warning_penalty = len(self.warnings) * 0.05
        
        return max(0.0, base_score - error_penalty - warning_penalty)
    
    def is_ready_for_review(self) -> bool:
        """Check if implementation is ready for Navigator review."""
        return (
            self.status == ImplementationStatus.COMPLETED and
            self.success and
            len(self.errors) == 0 and
            len(self.artifacts_created) > 0
        )


class DeveloperContext(BaseModel):
    """
    Context information for the Developer Agent.
    
    This aggregates all the information the Developer Agent needs to
    generate appropriate code solutions.
    """
    
    # Task and requirements context
    task: Dict[str, Any] = Field(
        description="Task definition from the PM or workflow"
    )
    requirements: Optional[Dict[str, Any]] = Field(
        None,
        description="Requirements from the Analyst Agent"
    )
    
    # Repository and codebase context
    repository: str = Field(
        description="Repository identifier (e.g., 'owner/repo')"
    )
    base_branch: str = Field(
        default="main",
        description="Base branch to work from"
    )
    existing_files: List[str] = Field(
        default=[],
        description="List of existing files in the repository"
    )
    
    # Technical context
    project_language: Optional[ProgrammingLanguage] = Field(
        None,
        description="Primary language of the project"
    )
    frameworks_used: List[str] = Field(
        default=[],
        description="Frameworks and libraries used in the project"
    )
    coding_standards: Optional[str] = Field(
        None,
        description="Coding standards and conventions to follow"
    )
    
    # Integration context
    previous_iterations: List[ImplementationResult] = Field(
        default=[],
        description="Results from previous iterations"
    )
    navigator_feedback: Optional[Dict[str, Any]] = Field(
        None,
        description="Feedback from Navigator Agent"
    )
    
    # Constraints and preferences
    max_files_to_create: int = Field(
        default=10,
        description="Maximum number of files to create in one iteration"
    )
    prefer_incremental_changes: bool = Field(
        default=True,
        description="Whether to prefer small, incremental changes"
    )
    
    # GitHub service integration
    github_service_available: bool = Field(
        default=False,
        description="Whether GitHub service is available for file operations"
    )
    
    created_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="When this context was created"
    )
    
    def get_iteration_number(self) -> int:
        """Get the current iteration number."""
        return len(self.previous_iterations) + 1
    
    def has_previous_feedback(self) -> bool:
        """Check if there's previous Navigator feedback to address."""
        return self.navigator_feedback is not None
    
    def get_language_from_context(self) -> Optional[ProgrammingLanguage]:
        """Infer programming language from context."""
        if self.project_language:
            return self.project_language
        
        # Try to infer from existing files
        extensions_to_languages = {
            'py': ProgrammingLanguage.PYTHON,
            'js': ProgrammingLanguage.JAVASCRIPT,
            'ts': ProgrammingLanguage.TYPESCRIPT,
            'java': ProgrammingLanguage.JAVA,
            'go': ProgrammingLanguage.GO,
            'rs': ProgrammingLanguage.RUST,
            'cpp': ProgrammingLanguage.CPP,
            'cs': ProgrammingLanguage.CSHARP,
            'sh': ProgrammingLanguage.SHELL,
        }
        
        for file_path in self.existing_files[:10]:  # Check first 10 files
            ext = file_path.split('.')[-1].lower()
            if ext in extensions_to_languages:
                return extensions_to_languages[ext]
        
        return None
    
    def get_relevant_existing_files(self, max_files: int = 5) -> List[str]:
        """Get most relevant existing files for context."""
        if not self.existing_files:
            return []
        
        # Prioritize certain file types
        priority_extensions = {'.py', '.js', '.ts', '.java', '.go', '.rs'}
        important_files = {'README.md', 'package.json', 'requirements.txt', 'setup.py', 'pyproject.toml'}
        
        relevant = []
        
        # First, add important configuration files
        for file_path in self.existing_files:
            filename = file_path.split('/')[-1]
            if filename in important_files:
                relevant.append(file_path)
        
        # Then add files with priority extensions
        for file_path in self.existing_files:
            if len(relevant) >= max_files:
                break
            ext = '.' + file_path.split('.')[-1].lower() if '.' in file_path else ''
            if ext in priority_extensions and file_path not in relevant:
                relevant.append(file_path)
        
        return relevant[:max_files]