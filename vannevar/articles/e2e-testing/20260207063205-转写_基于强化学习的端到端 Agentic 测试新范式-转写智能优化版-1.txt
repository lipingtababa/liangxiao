Ryan(00:26:18): 喂我能听到吗。

Quanzhi Fu(00:26:24): 可以听到。

王艺辉(00:26:32): 这么多人。

Ryan(00:26:34): 对今天人也蛮多的，我把视频也开一下。我背景。

Ryan(00:26:47): 哈哈！

Quanzhi Fu(00:26:53): 那我们到时候就八点钟准时开始，然后就交给 ryan 控场。

Ryan(00:26:58): 可以视频的录会议录制是您那边直接可以开云云录制的，那我先分享一下我这边的屏幕吧，然后这样的话。

Quanzhi Fu(00:27:05): 对我开了自动录制。

Ryan(00:27:18): 好看一点。OK 能看到吗？

Ryan(00:27:26): 行，那我就这样分享吧，不用看这边左边是我们左边是今天的嘛，今天我们做端到端测试的，然后其实明天还有一场，明天是说做 agent 软件工程这边的一些东西，明天是主要是马工在主持嘛，然后今天就是想让我来主持一下，再等一等两分钟吧，等两分钟我们看一下人都到齐了，我们再开始。

马驰(00:27:38): He. 

马驰(00:27:53): 搞个投票，谁最漂亮，大家投票吧，这四个人谁更帅。He. 

Ryan(00:27:56): 哪个 He. 不要挑起对立，大家都很帅！

王艺辉(00:28:07): 很帅都很帅！

马驰(00:28:08): 有朋有一个朋友看我发一个照片，他说马斯你真的像个美国的 honey。

Ryan(00:28:18): 像讲师的风格，没有这群里面不都是劝你改成小红帽吗？打造自己的一个特点。

马驰(00:28:23): 搞得我从此成了我的心结，我一定要重新拍一个还没买到。

Ryan(00:28:37): 还没买到，得国内这方面还是得国内比较快。

Ryan(00:28:45): 八点我们再等一下吗？等一分钟还是现在开始，小小辉在了吗？OK 那我们现在8:01那我们现在开始吗？还是再等一下？

马驰(00:28:50): 对。

王艺辉(00:28:52): 我在在。

马驰(00:28:59): 我们开始吧！

王艺辉(00:28:59): 可以就开始，反正其实就跟大家交流一下嘛，也不是什么特别牛逼的，有问题尽量喷我，然后学习，互相学习，那我就直接共享屏幕了。

Ryan(00:29:13): 行，那我先简单说一下吧，因为我们整个对我们的会议，其实今天我们可以看到我桌面上现在分享两个海报，因为我们是一个算是马工拉的一个比较社群的一个性质吧，然后我们在一起探索在 AIA I 时代，我们的代码或者是软件工程这方面怎么样进行后续的一些，可能说是进化叫 revolution。

王艺辉(00:29:14): 对你先说一下吧。

Ryan(00:29:37): 然后在探索过程中，我们可能会定期分享一些我们在阶段性得到的一些想法，或者一些成果，或者是一些遇到的一些问题，然后我们今天的话，现在八点钟我们进行分享的是一个端到端测试，然后今天我作为一个主持人吧，因为之前我在很久之前吧，也不算很久之前，也进行过我们公司的一个端到端测试的探索，因为当时。我们在 AI 生成代码方面已经有了一定的进展，然后在测试方面，我们公司针对于端 AI 进行测试，就是类似于一些主流的一些产品嘛 play right 或者是 chrome in develop 这种东西都针对于相当弱的这个影子节点很难去穿透，所以我有做了一些探索，然后今天借此机会马工就让我。

Ryan(00:30:28): 作为主持人，然后去主持这个会议，然后有我们小辉去做一些端对端测试的一些分享会议，然后我们现在看到左边右边明天还有一场会议，所以我们今天先进行我们这个端对端测试的分享，大概就是这么一个背景，明天的会议也请大家关注一下，然后现在我们把，让小辉分享一下吧，小辉分享屏幕，我这边也没什么。

王艺辉(00:30:53): 我这边可能讲的和大家传统理解的可能还会有一点区别，然后因为我这边讲的就是大部分东西是来自于我公司的案例没有特别多的能放到这，我更多的讲的是一些我对这个端到端测试的理解，还有一些类似于强化学习的这种一种概念，然后刚刚就是主持人提到的，比如说。

王艺辉(00:31:18): 碰到一些卡点可能得更多的交流一下，因为我的场景是比较闭环的，我自己是 O 整个前后端就所有东西都是我自己可以搞定的。OK 我就直接开始，我今天其实讲的主要是在我的这个博客上面也有小辉点酷。然后我主要是讲两两篇内容，一个是端到端测试，然后另一个是关于端到测试的一个应用，我先讲一下这个理论的部分。然后大家有什么问题就直接打断我就好了，没有任何关系。OK，首先，先抛一个观点测试。我不清楚是不是共识。首先测试 AI 时代？我觉得测试是复兴的，并且是测试是最重要的是第一个公民了，因为现在代码它的生产成本是越来越低的，那如果你没有测试验收，这个代码就变成了 AI，就变成一种泔水一样的东西。那你这个测试就变成了更重要的一个东西，尤其是对于现在就是大量写用 ai coding 的你连续用了几个月维护同一套代码就不是做玩具，是我同时在一个生产的应用。上面连续几个月开发，你就会发现你没有测试这个东西是没办法绕下去的，你喷的越多那个代码就会变得越丑陋，最后你的维护成本比你松懈的成本还要高！

王艺辉(00:32:32): 在不停的开发当中，因为我本身也是主要做的是 AI 的平台，我个人是这种业务方向，也不是那种纯业务的做着过程中，我会发现我的 ai coding 的本质上是一种拟合需求的大型强化学习场景。它就是在传统的软件工程里面测试，它是质量保证的一种手段。那么在新的这个看法底下，它是一种给 AI 反馈的一种手段，它不单单是质量保证，它是给 ai1个指标反馈的就是我要假如说我这个系统不是简单的一个 crud，我是带有某些指标提升的这个诉求的。测试它本身是起到这种反馈的作用。这种反馈如果一旦闭环了，尤其在端到端的测试场景下，那它就。可以做到一种强化学习的作用，帮你把整个系统的一些指标都提升，不管是性能指标还是说你的一些业务指标或者 GMV 这些指标，它都是可以来做实验的。

王艺辉(00:33:24): 那我下面就介绍一下我对端中测试的一些理解，这里是我之前在极客时间上去买过一些课，然后是那个纽生，包括像那个徐浩就是。沃克那个 CEO CTO 他们提的一些一些一些说法，我还是比较认同的。首先写测试本质上的原因是因为我们觉得这个测试能提高我们的开发效率，是判断这个 ioi 的那测试它本身也是一个代码的一个部分，写写不写，它写多少，写什么都是用 ioi 来保证的。

王艺辉(00:33:55): 通常来说，这个测试，它从上到下会分为三种，一个是 UI。1个是接口，一个是单元测试。在传统的软件工程里面一般是越往下它的 UI 是越高，因为越往下它的运行成本越低，运行的次数越多。然后端到端测试是什么？端到端是在我这里看来，它其实通常来说，对应的对后端来说是一种集成测试。那么对前端来说，它就是带着 UI 的一个测试，但是它更本质的端端端测试是更本质的测试是它是否有这个外部的 mock 那如果说我们的集成测试是处于单元测试和端到测试中间的一种状态。就集成的时候，它可以集成的是几个模块，也可以集成的是更大的模块或者是整个系统。那么如果说我所有的外部服务都 mock 掉了，比如说我的 db 我的依赖的这个333方的 RPC，我依依赖的某些 http 接口都被 mock 掉了。它你不管集成是 mock 的这个模块有多大。

王艺辉(00:34:54): 它在我看来都是一种单元测试，如果说在另一个方向走，如果你所有的外部服务都是真实的，这里真实不一定说你真的是调了对方的接口，你可能说你 mock 了对方的 RPC 接口，比如说你现在去配合银行去做一个什么系统的改造系统的对接，那这个银行的外部服务，被你完全 mock 掉了，你完全符合它的 openapi 的契约。那我认为这个集成测试不管它多小，或者说哪怕它就是个单元测试，我们也可以认为它是一个端到端的。因为它的所有端都是真实的，这个是我个人的一个理解，我说先定义好这个当它是一个一个是说法。在 AI 时代，我们之前就是包括这里提到就是说至少是有三种嘛，之前，然后包括你可以在网上会看到更多的一些其他的这个测试的概念，这些这里我是不打算赘述的。在我看来，在 AI 时代，所有这些测试的开发和维护成本都被大大的降低了。那我们尽量的就应该去做端端测试，而其他的就更少的被考虑掉，因为你不管是写测试还是 mock 测试的成本，你哪怕是 mockdb，你甚至都可以让人家去做一个 mock db，甚至都可以本地去写 SQL 去把这些东西全部给他准备好，那尽量的做到贴合生产环境，这样你的代码可以在本地去多次测试完之后就可以推到线上，很快的达到一个可以部署的状态。

王艺辉(00:36:15): OK，然后端到测试之后，我们就要考虑说我有我要去追求这个端到测试。我首先第一步我要去设计这个测试用例，那么测试用例，就不得不提到这个一个比较激进的这个流派就是 tdd 的测试驱动开发。

王艺辉(00:36:33): 测试驱动开发是一种比较高阶的这个工程技巧，就求我这边虽然是在介绍这个，但是我个人其实也没有很好的用起来。我之前是最早的时候我最早的时候写 java 的时候是比较喜欢用 tdd 的，但是它确实比较耗费功夫，然后会对这个你对需求的理解要求特别高，你要把这个需求很好的理解，并且拆分好了假，你要假设那个甲方或者你的业务方不能太过迫卸你，那么这个提议我觉得大家都了解一下，首先，它的核心是说我。他先写测试，就假设核心是说先写测试的核心，你要对这个需求有足够的理解，你不是上来就写代码，不是在编写的过程中编理解，而是你下来先拆解好你这个需求到底要不要做到底要做哪些内容，哪些功能，然后对应的就是你翻译成测试代码，它对应的是哪些模块？

王艺辉(00:37:26): 我这里比如说我举个例子，这也是我之前我练习的时候写的这个比较常见的一个例子，假如说你现在要从零开始实现一个 java 中的这个栈 stack 这个东西，那你怎么样，你当然是可以从零开始写，我现在去写一个站的类，我假设它里面有什么什么方法肯定是没有任何问题的。tdd 的方法下？

王艺辉(00:37:49): 你就是可以说我先假设我有这么一个站站的这个类，我甚至都可以没有，我就先好先写好了这个名字，那肯定是爆红的嘛，这没有关系，爆红的就是你那个类都没有，是爆红的，然后底下你再去想它有哪些方法，这个方法，你也不用实现，你就只用去想这个方法它会有哪些行为，它叫什么名字就比如说它最开始你有一个站站它会被溜出来。溜出来之后，它至少要支持一个实际化的动作。那支持实际化动作。第二个可能是说支持一个 empty 的一个方法。那有 empty 的方法之后，empty 的方法假如说没有的话，它你去泡泡它可能会报错。就是你可以去直接先把这些东西全部定义好之后，你去 run 的时候它上来，比如说你这边假如是已经开始 run 了。你点这个 run 的时候100%那首先连 stack 都没有，它会报错？那很简单，那测驱动的第一个东西就是让你去实现这个站的类，然后这个站的类现在是空的，紧接着你运行下一个方法，那比如说它没有六方法，那六方法肯定会报错。所以驱动的第二个方法，就是你要有一个实际化的 constructor 这个构造器，那紧紧接着第三个，可能方法去驱动你去构造一个 empty 方法，这个思想就是这么个思想，真的你去实际开发的时候。

王艺辉(00:39:05): 他是你会觉得有点蠢，这个是比较累赘的，但他但是这个思想的本身是告诉你说你不要害怕去实现东西，你你重点是想清楚你要去实现什么，你经历过这个红利循环去不停的从零到一把你这个迭代出来，或者说，还有一种学派，就是说刚刚我提的是可能是更通常的是芝加哥学派，还有一种学派是伦敦学派。他强调说，那我就实现这个站。我对这个东西我是很熟悉的，我已经想的很好了，胸有成竹，那我就 OK，我就上来就可以先写一点接口上的东西，我不用说真的是完全的红利循环，我可以先把这个站写了，然后写一些空方法，只是我在这边可以把冲突测试的方式，把这个方法的行为描述的更加仔细，然后来再驱动，这实际过程中，是这两个都会去结合的，你既可能对这个需求足够了解，也可能对这个需求不足够了解。

王艺辉(00:39:55): 但它核心就是说我们把这个需求拆解清楚，然后从零开从零到一去写它，然后拆解清楚的话，这里有一个法则，这个法则也不是我自己总结的，这个叫，这个也是比较通常的一个 gwt 法则，它是三个单词的缩写。第一个说 given 就是你在什么情景下采取什么东西，当什么时候采取什么行动，最后你会得到什么结果是这样得到什么结果。所以 gwt。

王艺辉(00:40:23): 对于一个通常的，比如说你一个前端的项目来说，那么可能就是说用户动线，那么用户，他进入到一个页面，他会看到什么，他要他可能会有什么样的一个点击行为之后会触发你后端一个什么样的接口，这个就是你从你的用例的来源，也是贴贴近用户实际工作实际行为的一个来源。那假设比如说这里，你有个电商搜索的页面。你就可以假设说，用户现在已经进入到这个页面，他首先会看到什么，或者说看不到什么，那他输入了一个什么之后，你的这个页面会有什么样的一个行为，这个就是然后假如说他点击了之后，他可能会进入详情页，然后会有一个什么行为，然后页面上大概会展示什么样一个骨架，这是一个 gwt 的最简单的展示。基于这样的在 AI 时代，这种东西它其实比。

王艺辉(00:41:14): 最开始就是像就我们以前写写测试是要写，不管你是写伪代码还是写真实代码吧，都是有一钉钉成本的你至少得写个东西出来。那 AI 时代，你其实就可以有这个东西就可以了。你不用写真正的测试，最起码在我实践当中是可以的，你你只需要把这个东西，这个东西也不需要你写这个东西，你可以说让产品先给你一个用户故事，或者你自己去想一些用户故事，想一些用户东西，把这个东西基本上。你先 review下这个东西，拆解清楚 AI 是可以完全理解出这个东西的，而不需要你去真正的去把这个代码给它写出来，然后他自己在测试的时候，他自己可以去写代码去测。然后基于这个用户动线的方式，你把这个测试用例已经设计好了，设计之后，那就上 AI 去执行。那执行过程中，尤其对于前端，他怎么大家都可能会说 playright 那我个人推荐的是这个 chrome dev tools 这个 plugin 我觉得这个东西用的是还算比较 OK 的，因为因为它首先是 google 官方出品的嘛，然后他也是甚至可以去看那个 dev tools 中的那个日志。所以我个人是一直是比较用的。

王艺辉(00:42:18): Ok. 这个其实就是开发的内容，然后前面这是相当于是前端开发的前端加后端开发的，然后后面，如果你是后端的话，通常来说你会有一个 openapi 的契约，这个接口，我们是要在那个你在，或者是在里面，你要去提醒一下，不要上去更改，不然他可有时候可能是在特别是对于一些强化学习训练。

王艺辉(00:42:45): 比较过的模型，他会去黑盒，你的这个测试结果他为了这个东西通过，所以这个东西你可能是要重点去检查的，你在比如说你看那个 commit 的时候，你发现这个东西不要被改变。那么基于这个契约，我们重点是要搭建整个的这个测试流程，这个流程其实它有很多细节，你真正去跑的话，会有很多的细节，尤其是你会发现你比如说最简单的，你可能你你你本地。的环境是起不来的，你环境起起来之后，可能还依赖了某些全局变量会打架，然后你可能还会依赖某些硬编码的东西，这些都是细节。但总体来说，它是模拟的就是你人怎么去怎么怎么去部署这个应用怎么去看日志，怎么去测试这个接口这些东西，你要提前的就是把这个环境给它做好，我现在的工作，我现在日常生活中，我所操心的事情，都是说把这些东西。我们要给它描述好，然后让 AI 去更好的理解这个东西。但是现在就如果说你从一个人开发的角度，你把这些东西都准备好了之后，他是可以自己把这个过程给撞起来的。Ok. 这里就提到了一个循环的概念，就是说我们现在已经假如说把环境都搭建好了，那么已经有了端端的测试了，那么 AI 它如何能够自动化的去测试这些东西以及它能做到什么地步，这个是我下一篇会讲的，我先，然后这篇先讲到这里，然后大家看有什么问题不？

Ryan(00:44:16): 今天就是先去尝试去端到端测试一个前半部分的一个过程，就是后面我们循环优化是下一次再说是吗？行，那其实那我如果那我们行，那我们讲完最后再一起交流或提问一些问题嘛。OK 还是 OK OK 那您继续吧。

王艺辉(00:44:25): 没有我等会儿讲我是先停一下，那我就接着讲，那行 Ok. 那我继续好！

Ryan(00:44:41): 好。

王艺辉(00:44:43): OK 然后刚刚是介绍了那个端到测试的这个一些概念，然后包括它这个基于接口开发的一些东西。然后后面这里我就介绍一下。那怎么着这个端到测试你你现在这个端到测试，可能还是人，就是你是触发了这个，不管是 codex 还是这个你触发了他去干活了，他可能干活了之后他就跑跑一轮他就结束了，他就会说，我现在已经跑完了。

王艺辉(00:45:09): 然后我发现有日志可能有些问题，你需要我还需要我做什么，比如说我发现你这个日志里面提示那个404了报错404了。假如说你现在结果根本都没有实现报错404了怎么办？他可能会这么跟你说。那我希望的结果是他发现404了就是实现接口，你问我干什么，或者报500了。那你去找这个为什么系统报500了，你把这个修 bug 修掉就好了，那我们肯定希望是达到这种效果。OK 那这里就需要。模型它去进入到 agent 它进入到一个 loop 里面。然后我甚至是我们希望它进入到一个更智能的叫 agentloop 里面。loop 的话就是说他自己可以发现自己的这个错误，然后自己去反思，把这个 bug 给解掉。agent loop 他不单单可以反思他，甚至可以去思考说下一步应该做什么，这个系统从这个长期就是你这个需求的一个宏观层面上怎么去设计去演化，而不是说我提前 plan 好。就我 plan 好，这个肯定是 OK 的，这是没有问题的。但是有些需求，你的 plan 是不一定起到效果的，你的先前的 plan 是可能阻碍 AI 的发展的，然后我后面会介绍一下有哪些就什么样的需求，你相应的 plan 甚至是做不到的。

王艺辉(00:46:17): 这里，我就我先介绍一下，就是这个 loop 是涉及到的是 GWT code 生态的两个 plugin。这里我会先稍微嗦几句，讲一下，就关于这个 cc 的这个一些我理解的用法。然后这个也是说你因为你你你本身在这个 loop 里面，你不是完全让 AI 你自己需要去接管它。那接管你你可能有时候你会去用一些高级的用法。

王艺辉(00:46:43): 首先第一个是 CC 是一个 unix 工具，就是大家可能平常用 CC 可能就是在 term 里面去用。那这个东西，你是可以把它放到脚本里面去用的。你可以让你把 CC，当然你如果你本地有那种 python sdk 也是 OK 的，但是你直接把它写 SH 的命令写到脚本里面去跑某个东西也是 OK 的。就这个东西是可以很灵活的放到你你的整个一个工作流程里面，你在什么需要的情况下，就直接把它去用就 OK 了。第二个是说。cc 并发这个大家也都提到了，我看那个群里那个薛老师他的那个屏幕特别多，然后我最开始我用这个的时候，我是用 work，后来我感觉很麻烦，所以我就买了一台电脑，我买了台电脑，然后就并行的来进行开发，然后成本低一点的方式，可能就是说。

王艺辉(00:47:26): 你就可以自己就你你这个要机器的 Docker 能带得动，然后多开几个 docker，也可以做到一个并行的开发或者简单一点，就用这样的话可能会稍微麻烦一点，你可能切的会切乱一点。因为我们现在重点是提需求嘛，就从从现在这个开发方式上来说，我们变成了产品经理变成了甲方，或者说变成老板一样的角色，重点是管理说你就应该把自己的 CPU 打满你不停的去。给 AI 提需求，而不是应该等着他。还有一个很重要的功能，这个我不确定，大家可能很多人知道，但是我是其实我是一两个月前我才知道这个东西的。然后我就发现我不知道他什么时候推出这个功能的，但是我知道东西的时候，我感觉都知道太迟了，就 es 这个 cc 它你通过斜杠也可以去切到任何一个节点。同时，你直接双击 exc 这个命令，也可以切到任何一个节点。这个我觉得非常重要，这个功能，然后这个功能比我去用 cursor，还有那个像这些我觉得比他们要好，因为他们切到任何一个节点，他们是可以帮助你去回滚这个代码。

王艺辉(00:48:28): 但是他不能选择你不回归这个代码，然后我很需要的就是这个上下文可能已经接近腐烂的状态了，我希望他切到最开始的某某个节点，但是我希望它中间的这些代码变更都被保留，我就很希望是这样子，因为他可能在最前面，比如说我已经跟他沟通了五轮了，他已经有一些，比较好的上下文的知识了。或者他已经获得到了某从哪里获得到了一些的知识，我不希望这些上面被丢掉，重新开始，虽然现在它可以去卸载到这个文件系统在读，但是它本身已经有了不希望重新开始。所以我很希望的一个功能就是说它回到任何一个节点，这个节点，它的代码被保留着。同时，我通过一些提示，可以继续让它去之前的工作就是我比如说到第十步之后的工作，然后我现在回到五步了，所以我觉得这个功能是很重要。

王艺辉(00:49:14): 很有用，还有一个那关于 cc 上下文工程，就对于更高级的用法是你自己可以去写各种的 hook，然后去左右 cc 在某个地方去干什么，举个例子，假如说你现在企业内部开发你或者不单是企业内部开发你自己开发，你很希望的做那个工作，你的文档跟你的代码始终是同步的，你文档跟你的代码始终是同步的很。不好保证你在 glodmd 里面写再多，你跟他说，你每次提交前都要怎么样，他总是会忘的，尤其是他的上下文腐烂之后，他就已经不管不顾了，那但是你可以去写个 hook，直接强行拦截他。在他去，比如说最后去提交之前的 commit 提交也是一个提交，或者在 stophook 提交之前，你跟他说，这个东西你你有没有去更新文档，你可以去百分百去保证他至少去思考了这个东西，然后去做。

王艺辉(00:50:08): 这是一些高高级用法，然后就可以写，后面介绍两个 loop 的工具，也是用到了这个 stophook，然后底下就是说，这个 hook 它本本质上也是属于这个 plugin 生态的一部分。skills 最近是比较火，但 scale 也是这个 plugin 生态的一部分。现在不管你是安装 mcp 还是安装 commands skills 都是通过这个 plugin 的方式去安装的，这个可能大家也都比较熟了。我。

王艺辉(00:50:33): 这里也是列了一点点，这个我觉得比较好的 mcp，然后两个 loop 的 plugin 1个是这个 roughloop 这个最近也是特别火。不知道大家用起来没有，然后这个实际在用的过程当中，我先介绍一下就是 roughloop 的话，他的思想就是说你以人去开发这个需求本身提需求规划实现 review 实现需求本身也是个 loop。那么你你你把这个 loop 就让 AI 去就我刚刚说的，你让他直接在他每次停下来问你的时候让他反思，比如说这里有个实际的例子。请你仔细理解验证优化指标的流程怎么怎么目标是什么什么什么，不管是目标怎么怎么，他每次停下来之后，他可能上一次会跟你说我要干什么，然后我要干什么，停下来了，停下来之后触发了 stop hook stop hook，他就紧接着会把你之前最开始给他这个 R 里面这个语句就带给他了，重新让他去思考。一直会迭代到最大轮次，或者是让 AI，他会自己去判断我到底有没有把这个事情完成。然后就起到这么作用，它可以不停的去强制 AI，在它没有确定它完成了你的需求之前，它会一直迭代到达最大轮次。然后这里就是通过这个 plugin 的方式安装就可以了。

王艺辉(00:51:56): OK 那么这里可能就是懂行的人稍微懂行就会说那上下文不会爆掉吗？你这个跑十轮，我是想他跑一直跑下去有用吗？他不会爆吗？那确实他不会爆。那 rough loop 他在这他的那个脚本里面会强制去。其实在每一轮重启的时候，会把之前的那个进程给干掉，重新启动，他在他的 command 里面会要求 AI 把他的一些东西，就通过 rough loop。那个文档这个用的话就知道就写写到一个写到一个地方去，然后下一次启动的时候，他 AI 会再去读那个文档，这样会起到这样，基本上在你单次这个需求不是特别大的情况下，就是你单次这个一轮的不是特别大，还是可以一直往下跑的，然后什么时候是一轮就会爆掉，你跑的时候？可能比如说他自己会打很多日志，他自己是有可能打很多日志的，然后他就。不知道他打了那么多日志，他直接读了一下那个日志的文件，直接就打包掉了，这是很有可能的，但是我确实我自己也是跑通了六个小时以上的任务，就是我去跑我会跑一个指标，我最近一直在做这个需求，就是说提高我们一个 agent 的这个幻觉的这个检测的能力，我希望提高他整个幻觉的检测的召风险样本的召回率，那我就会。

王艺辉(00:53:13): 一直让他去跑，每天就7.24小时让他去跑，我个人实践就是说我睡觉之前我让我触发一个基本上我睡觉之后还在跑，是被我验证的是没有问题的。

王艺辉(00:53:25): 但是，现在其实我个人觉得就我用的已经是 Solid 4.5了，我觉得它还是不太够智能的，它跑跑多了之后，它会进入到一种很，它是有可能会进入到一种，就是说没有那种意义的循环当中，它会不停的反思说我要做什么，但它反思的东西，可能在它前几轮已经出现过了。这里可能你这个提示词需要写的更复杂，这个是我最开始的一版。这个其实你可以写的更复杂一点，给他更多的一些启发式的反思，你如果仅仅是让他反思自己，假如说让他去反思，让他去尝试怎么去优化他。没有一些方法论输入的话，他很容易就会陷入到自己的一个喃喃自语当中，或者说不是喃喃自语，但实际上它本身的进度是没有提高的。

王艺辉(00:54:12): 这个是说的是一个单纯的这个 loop 就是你不停的去促使他去反思，每次这个反馈都是一样的，那很简单的。还有一种就是我彻底代替人，我作为人，我在这个 humanin loop 里面我经常会给他一些意见嘛，比如他会，他会问我说你要比如说你现在这个架构选 a 还是选 B 你你是你是要怎么实现类似于他可能会问你一些说法，那很简单，那假如说现在。有一个 agent 他就跟我一样，他有我的经验，他有我的偏好，他自己可以代替我去给这个现在这个 cc 再去发号指令，那是不是就完全不需要我了？这个理论上就是可以不需要我的，如果他确实能做到我给 cc1样的反馈的话，这里就是有一个开源项目，然后我之前也贡献了点代码，我觉得这个是很好的。

王艺辉(00:55:04): 然后他的一个思想就是说我真正去扮演这个人的角色，他在每一次的时候，他会把那个你的上下文给 fork1份出来，这样也就避免了你上文被爆掉的问题，fork1份出来，然后把这个 fork 的这个上下文再去丢给另外一个模型。然后另外一个模型，他收到的指令是说他不会去改这个代码，他只会去评估你当前工作的质量，就不单单是这个代码。质量还是说整个从最开始的需求开始，你这个整个架构设计代码实现的这个质量，然后来确保你这个当前你 cc 就相当他督工了，他监督这个 cc，你现在真正在干活的这个 cc 并没有偷懒。我个人用下来这个效果还是比较好的，不过这个东西还是有点 bug 的东西。反正用了就知道了，就是用多了还是有点 bug，然后我个人是就是你在你 token 足够的情况下，我是倾向于用这个的用 supervisor，它会给你带来一个比较好的效果，然后确实也是也可以做到一个启发式的。

王艺辉(00:56:12): 他确实可以提供一些意见，甚至你比如说你可以，你把这个东西给他换成 opus 嘛，然后这个可能执行的可以换成稍微弱一点，换成 ktwo。OK 但这里其实也要提到。虽然 super 很好，但是它对于复杂的需求依然是不能胜任的，就这里最起码在目前的这个模型的状态下，我发现人的价值就可能对我看来核心人的价值，那就是做判断的能力，做决策的能力。我这里有一个实际的例子，这个是我在这个手机上跑的结果今天早上刚，上午刚跑的上午刚跑去他7.24小时跑，他跑到他这里，他跑到了某个阶段，然后他说他给我提了这个四个选项，他说要做什么，那他自己反思说我要进入选项 a 了我就打断了他。你这肯定是选项 B，他会觉得说我在某个阶段的指标已经符合需求了。我可以妥协一下，然后就再去做什么。但在我看来，这个东西你你肯定是应该把一个东西给掌握了再去做下一个模型，它很多时候它会进入到一种偷懒状态，它会采取一些走捷径的办法，或者说它会有一些比较短视的方法。

王艺辉(00:57:24): 我不确定是不是所有的模型都这样，但是我用下来，grow 的几个模型 K two 的几个模型，然后，其实我觉得那个 GPT 还好一点，因为 GPT 它有时候会比较严谨一点。但是他们都有一个倾向，就是他会倾向于达成目标，这个目标怎么达成，他不是那么关心他，也不关心你后面的维护成本，就他并没有很长远的一个规划，那这个时候，人的判断就很重要，你你你就是你你你对这个整个架构的坚持，对这个价值的输入就很重要。

王艺辉(00:57:53): 那么最后就再提到是这个，我把整个流程就跑下来，就我最开始提到说你端到测试了，假如说你一个 CR 的需求，我相信，其实现在 cre 的需求，一个确定性的需求，你基本上用这个，不管是用简单的 loop 还是 agentloop 的方式，只要你的测试够好，你的需求够明确，他是可以完成的，就自己来完成，我之前。也其实也开发的，就我之前也会做一些 CD 的工作，然后我就这么做的，基本上是百分百都不会完，都不会用到那个自己去写，然后确实也不会写，因为我现在比如说我在手机上开发，我这里面只能跟 AI 交互，我没有终端，就是那个 ID 去看他也去改它，我能做的不停的去给他 P 它去给他反馈。

王艺辉(00:58:42): OK 那还有一些需求是你即使你自己想了很多，你也完成不了的。我这里这个需求就是我提到的，比如说我现在去做一个 agent 我要 agent 去检测某些东西保保证他检测那个东西没有幻觉，或者有幻觉，给他提这个真实的建议，让他去改改动改变，就这个要求就是我检测这个 agent 本身就要很鲁棒，本身就要很聪明。我就需要去用，我就我们团队就会去招一些外包同学就会打这个 benchmark 还要去给他们培训就成本还挺高，就每个 case 都会去找精算师，找那个。人去标注完之后，比如我现在标了200个样本，那我希望是他在这个200，200个样本上面反复跑，能让他这个准确率就是他标他达到的效果，最后跟精算达标的这个效果是一致的。至少能达到90% 99，这样我会相信任说这个 agent，它是可靠的，然后它可以去检测其他的 agent 的输出效果。那么其实是一个就类似它本身是一个算法问题了。它可能会涉及到一些比较复杂的架构，就你最简单的做法就是你写一个 Prompt，然后你把所有的他能拿到上下文就丢给他，然后你跟他说从里面找一件错，这个是最简单的做法，那这个做法你就会发现。

王艺辉(01:00:12): 它的最就是你在没有特别的情况下，它的那个准确率可能只有5050%分之60就很低，然后你调一调，可能你也就能调到个70% 80，然后基本上你每每每往上升一个点都很困难，而且你不并不清楚你调到什么程度就变好了，调到什么程度就变坏了，那就它。这个时候你就不是你自己人为设计架构能解决。

王艺辉(01:00:37): 事情你要去尝试大量的策略，包括你的 prompt 调的本身，你要尝试大量的这个 prompt 这个策略，还有你的架构的策略，你可能要拆出很多个专家的模型，然后采取一些启发式的方法，采取一些规则性的方法，把你这个对应的业务的这个上面，这个知识，给它融合到你的这个代码里面去。那么这个东西，我不希望是人调的，那么人调的成本太高了，我就做了这么一个系统，这个系统就是类似于强化学习的思想。只不过反馈就改成了由这个端端的测试去给反馈，端端测试，其实就是这个 benchmarkbenchmark 给反馈，并且为了让他尽快的反馈会拆除小的 benchmark 和大的 benchmark！

王艺辉(01:01:20): 把这个流程给他搭建起来，就让 AI 自己去每一次迭代的时候，向他去做一个实验，他每次假装这个代码是一个实验，然后自己去想一些启发式的策略，把这个代码切到那个分支上，他把那个代码去提交，然后看一下他当前这个实验的效果，然后你同时可以在多个机器上去跑实验，然后看哪一版的 AI 最快达到你既定的一个预期，然后把。再去合到主干上，然后其他 AI 把那个代码拉下来之后，基于新的那个实验再去进行迭代。这个可以看这个其实就是我现在这个过程，我目前我这个一个指标，其实从零我是真的是从零开始，我特地没有去，我其实人可以去先验输入一些东西的，然后我就想尝试一下 AI 能做到什么地步，那目前这个东西他跑了大概两周吧，然后因为跑到86%了，然后我可以保证没有，我反正我是没有改一行代码的就全程是他自己去做的，然后这个大部分工作是也是。在这个手机端去完成的，就手机端这个，但是手部手机端是一个只是一个 bonus，你这个你用电脑其实是一样的，只是手机的话，我可以去随时去看他一些一些一些进度，让他自己去做规划，去跑这个东西跑东西之后，去把结果反馈就可以了。

王艺辉(01:02:40): 这里是我的一些截图，然后我这里还强调了一点，比如说可能放大一点，就当时我最开始做这个时候我还挺高兴的，就他这个 V 版本，他这里，他发现他改 prompt 改到61%的时候，他觉得他改不动了，他已经迭代了好几轮，他说他改不动了，改不动的时候 try a different level 然后他就把 different 打打了一个大的 different level this decrease recall without change prompt 就他成功通过启发式的方法，他觉得 OK 我不能再去这么调 prompt。调下去了，这人可能就是调不上调下去就很多人，他就是这个时候，他就开始进入到他对架构的这个改变，那他就进入到了一个深水区，可以真正的去提高我整个这个 VR 系统这个能力。

王艺辉(01:03:28): OK，然后到这里的话我就分享完了。我后面还会去新的去介绍一下，就这个 loop 里面还会有一些具体实现的细节，就我现在这个介绍的是说这个整个流程，然后这个还有一些具体实现的细节，我还没有来得及去把它梳理出来，然后后面的话我可能会，再去写出来，然后分享到我的博客或者公众号上，然后我今天就先介绍到这里。

Ryan(01:03:56): okok 那您先分享到这里，然后我看现在聊天中没有什么太大问题，我其实也总结了一些问题，也是群里面之前在针对于这个分析我们分享会，然后也搞了一些问题，就是有一些问题，我这边直接问还，我们就直接聊吧，然后您这边就分享着你，你现在的那个，分享的内容，想一下我们在。

Ryan(01:04:22): 群里面我们那个蒋老师也问了，就是我们怎么样把测试能完全交给放手交给 AI 去做，就是这个东西我们怎么样能做到真正去信任他，就是他给我们要什么样的一个结果去信任他，就是直接他们给我们的结果是一个怎么评判标准，比方说刚刚说我们的召回率从零到86%，这个八86%他到底是怎么得到了这个结果？

王艺辉(01:04:38): 这个结果是你本身你就拿这个需求来说，如果需求其实更简单，因为这个需求是很明确的，你会有一个 benchmark，它会有一个指标的计算就指标是通过一个脚本去计算出来的，当然这个脚本是 AI 写的，但是写完之后你就是要 review 脚本的结果的，让他不要去帮他去 hack 掉这个计算的脚本，他会每次跑完之后。他会基于他跑的这个样本集去计算这个指标，他就可以很快的拿到他当前这个实验是不是合理的，并且他是在哪些地方失败了，那么对于更宽泛的，就其实这个是比较简单的这个86%这个东西，从这个从端到端测试的这个目标设置上是比较简单的，因为它的很明确，它就是某某某几个指标，只是它要实现这个指标比较复杂，可能日常开发中，更多的是你你有一个需求怎么办？你的这个需求可能不是明确的，所以我的做法是。就是我最开始就是的这个测试用力的做法就是通过 gwt 这种方式把这个测试用力给他描述的比较清晰，然后让 AI 基于这个测试用力去看。就他每次跑完他比如说先跑完这个。用力之后，他确认这个用力是不是完成了我最后 review 的是他这个用力没有完成。

Ryan(01:06:06): OK 也就是说本身这个按照 gwt 标准出的这个测试用例，其实更像是我们之前分享会里面闭麦的做了一个 U，相当于是类似于对 user test 或者是 user journey 就是用户故事的一种感觉，然后他会去判断说我当前的是一个什么场景下，完全覆盖掉这个场景，它是一个通过的状态是这样意思吗？

王艺辉(01:06:16): User case. 是的。然后这个是前端的嘛，如果你是后端的话，你本身是一个纯后端开发，那你可能就是你的 OPEN API 的接口到底是什么样的一个定义，你可以做一些 assert，这个都也没有问题的。

Ryan(01:06:42): OK 我们还是会人先去给他定一个标准，然后就是即使或者是一个计算方式或者是一个算法，然后去让他知道他应该具体化到什么程度，所以说它本身 AI 这个足够好的这个概念，还是人去定，事先定义给他的是吗？

王艺辉(01:07:02): AI 足够好的概念是他这个测试本身也是他猜的，但他猜到什么样的一个力度，拆成什么样一个效果，还是我们自己要去判断的。

Ryan(01:07:13): 也就是说人在 AI 在生成这个报告的时候，我们是人是需要去 review1下这些测试用例的一些评审和报告的，我们要事先去有人的参与过程当中去确认这个问题。

王艺辉(01:07:24): 对，并且我们最重要的 review 其实就是这个测试，就在我看来，就是测试它是现在是第一的功能就比你代码更重要，就是你代码，其实你你没有时间的话，你代码甚至可以不怎么看，因为它确实 ai1次性会写很多代码嘛，你没有时间代码可能可以不怎么看，但是你的测试是一定要看的。你一定要看他是不是 hack 了，你的测试他是不是并没有关注到你，你关注的东西。

Ryan(01:07:52): 这个问题就明白了，就是重点是在于我们用端到端测试或者是用换种说法就是用测试用意去覆盖了我们需求里面所有的业务场景，然后我们注重的是一种结果，就结果导向嘛，他得到的这个结果是符合了我当时在测试中跟他提到的过所有的业务场景给他覆盖掉了。

王艺辉(01:08:05): 对。

王艺辉(01:08:17): 是这样子的，然后这里我再提一个，我这里还没有写，就是他这个代码其实还是也是很重要的，因为他可能比如说现在你你让他去做一个 cle 的，比如说你假如说做个用户登录页，这是很常见的，其实你都不用怎么提示他可以很好的完成这个，但他的代码依然是不符合你预期的，因为他可能把代码都写到一个文件里面完成了你的用户登录页，这是很有可能的，其实是你自己，就作为开发者一个有经验。开发的你提前是要去，可能是你去构建好一些目录，就这个可能是一些鲜艳的动作，你提前可以帮他去构建好一些目录，构建好一些这个 M 那个 md 文档说明就简单的一些说明，然后跟他说，你在这里面就是你不让他不要去乱写。

王艺辉(01:08:58): 这个是可以去先验去做一些东西，对就架构方面的东西，包括说你，你给他的那个 AMD 的那些规范，就是你也可以给他一些规范。

Ryan(01:08:59): 这个就是架构方面的一些一些标准了。

王艺辉(01:09:10): 他这些东西是你做好了之后就不太用管他了，就他最后写的那个代码，你甚至可以，比如说有我自己其实比如说我会有一个脚本，我会去检查他写的那个代码，是不是每个都超过了300行，是不是每个方法都超过了30行就是你可以去写脚本去跑的，可以强制性在 pre commit 里面去跑。如果超过了就提醒他你这个东西需要重构。

Ryan(01:09:33): 明白其实就是相当于我们之前类似于阿里，或者是其他一些大公司出的一些代码标准的一些方案，然后去让他去按照当时的代码标准方案去做自己的实现，是甚至于说我们在实现代码之前去进行了一个本身架构方面的一些设计，或者是一些，也是算是规则上面的一些限定？

王艺辉(01:09:58): 你架构设计是有必要的嘛，就是你在你确实是 O 这个项目的时候，然后是一个比较明确的需求的时候，就你你其实最关键的就是可能是架构设计，还有这个需求的结果，最重要的可能是需求的结果，然后还有一种就是我刚刚后面提到的吧，你可能没有一些先验知识输入的情况下，你架构你自己也设计不了。出来的情况下，你也可以让他去迭代。

Ryan(01:10:27): 明白。那还有刚刚我们还在说这个问题就是 AI 这个足够好的概念，我们事先给他定义了这个标准。他这个足够好是怎么说，比方说我们给他定了个标准，是否是一个比较符合预期的，比方说，你的账户汇率说他现在 AI 优化到61%了，他觉得他已经从提示词方面没有继续有好的优化方。然后他去换另外一种方式去做，那他们的目标究竟是多少，就是我们定义这个目标定到多少会比较合适，还是说我们按照常见的一些目标去定义的。

王艺辉(01:11:00): 这个目标是把这个目标，比如说在我这里，我最开始给他定的是80%因为我其实我这个目标从业务上来说，我是要干到99%的，然后我最开始给他，因为不太，我不太希望他太黑客这个样本级，然后他可能会对样本进行过拟合嘛，然后这个目标的话，是取决于你的业务诉求就是你你你可以随便定的很高也没有关，比如说我现在就直接写个百分之百是没有关系的。关系的话，他可能就是会为了达到这个目标，他可能就会害你的样本集，或者说最后迭代了很多轮，一直一直跑着跑，就是跑到这个20轮结束，我给他迭代20轮结束的话，他就会承认说，我以我的能力没有办法完成你的要求。

Ryan(01:11:43): 也还是我们给他做了一个限制，并且让他有一个循环的次数限制，就是相当于类似于我们之前 a 做的那个东西。OK OK 明白，但还是还有一点问题，就是我们如果用 AI 去做测试的话，我们这个稳定性是怎么保证的你你刚刚你说你用用 work，或者是用，多方并行的去做测试的问题。如果我们。

王艺辉(01:11:48): 是需要的。

Ryan(01:12:08): 对于一个测试同同样的环境，同样的条件情况下，我们跑两次让 AI 去跑，我问 AI 同一个问题，它的输出结果有可能是不一样的。

王艺辉(01:12:19): 这个这看你要测试的东西是什么了。就如果你测试的是最开始像 got 那种描述的一个用户动线的明确的东西，比如说他现在点击某个页面会出现什么一个页面，然后这个页面上展示的东西是从你后端接口捞出来的，那这个基本上是确定的，都可以去校验某个字段？每个字段。

王艺辉(01:12:40): 那可能说你现在是做的是一个 agent 的项目，或者说就是我现在这个吧，就拿我现在吧，我现其实你的校验，它虽然是校验指标，这个指标是好算的，但它这个校验的思考的结果就是它哪怕同样是达到了一个指标，可能这个 agent 是通过一些很 hack 的方法，比如说我碰到了 a，我就应该输出 B 碰到了 B，我就应该输出 C 它可能会通过这种方法来达到你的目标也是有可能的。那怎么？那我现在的做法就是把他的思考过程都打成日志，然后让 AI 去检查他的思考过程。

Ryan(01:13:13): OKOK OK 那我明白这个问题，然后我们看一下对话里面，马工也提到了一个问题，就是并行两台并行开发的问题就是怎么样确保红绿迭代失败的时候。AI 测试用力去尝试新的方法，就是可能是说我们多个并行，然后查看同一个问题的时候，这种情况下我们怎么处理，您也可以看。

Ryan(01:13:39): 下聊天里面？

王艺辉(01:13:40): 我看一下微信吗？

Ryan(01:13:42): 不是会议在聊天里面，腾讯会议的那个聊天？

马驰(01:13:51): 小红你可以把分享关掉。

王艺辉(01:13:54): 不想关了吧，这你聊的挺多了，我靠worktrain 不管。张西红绿循环写了好几年了，很强，两台电脑的并发达到了多少，怎么确保红绿？我的并发度首先，比如说我通常我自己在公司里面，我自己有一台电脑，我通常一般我会开四到五个窗口，取决于我个人对，就是我手上这个需求的这个掌控能力，我可能会同时开四到五个需要四个窗口，然后去，比如说我可能让他每次去实现某一个接口，实现其他的一个应用的不一定是我每次做的不一定是同一个需求就是其他需求。

王艺辉(01:14:46): 然后这个红利在失败的时候怎么去改车不让他去改车使用力，而是尝试新的方法。这个说实话我也没有特别好的方法，我这个只能是说你在提示词里面去那个，并且你去 review，就他提 PR 的时候，我会去看他的 PR，就这个我会去看的，我并不是真的是无脑，就是说，他现在告诉我说，你这个契约完成了我这个通过了我就直接合并了，我还是不行的，我们这个做的是生产项目，就他的 PR 我会是会去 review 的，并且我们这个线上的是。这个 PR 提过去之后，还会有其他的这个 agent 去 review 他的这个 PR，我会把这个 PR 的意见加上我个人的 review 的意见，再会去给大家基本上每次还是会改个两三轮，就并不是。虽然我不写代码，但是我确实要完成粘合的动作，粘合闭环的动作。

王艺辉(01:15:36): 然后再看底下和传统的开发不一样。对这个傅博这个说的确实就是我后面尤其我后面介绍的那种类似于强化学习这种闭环的方法，它是比较启发式的，它这个确实是不太一样的，就是我最开始做这个 a 做这个 V 的时候，我们其实最开始也做过一版，最开始是类似于自己写多的方式。

王艺辉(01:16:02): 去实现调 prompt 调的是比较痛苦的，那如果你切换到一种自动化迭代的方法，首先你是不用调 prompt 了，你更多的是关心这个流程，然后你可以消耗的，其实就是 token 你要管管控的是说这个流程不要失败了，就不要在你那个未知的情况下失败了。

王艺辉(01:16:20): 你只要不让他未知的情况下失败掉，它是可以不停的去迭代，把这个实验记录到你的这个代码库里面，然后你可以去，比如说他现在跑了70个实验，你可以让他去看这个70个实验都实验了哪些东西？那为什么他的指标假设指标没有提升的话，到底实验哪些东西没有提升，那提升是哪些地方有提升？

Quanzhi Fu(01:16:40): 我可以 followup1个问题吗？的后面的基于指标一直去迭代的这个循环就是你说的这个类似于强化学习的方式，就是你像我们传统强化学习，其实它经常会比如说我们训练的东西出现那个 rewardhiking 的情况，就是说它可能，练着就跑了。那你比如说对于我们这种大语言模型驱动的这些 loop 来说，你有观察。

王艺辉(01:16:42): 对你说。

王艺辉(01:17:02): 对。

Quanzhi Fu(01:17:12): 到类似的情况吧，然后。

王艺辉(01:17:14): 有的我刚开始举例也说过了，你如果仅仅是说比我给我完成一个风险样本召回率80%的目标，百分之百的目标之类的。他为了达到目标，他是不惜于把直接给你写死的，甚至他可能给你写一些 if else 的判断，他比如说你现在你其实有个你的整个测验证集是200个嘛，他可能会直接把200个都给你写写200个 if else，这是可能的，就 if 碰到了 case1了，给你返回什么？if 碰到 case2了，返回什么？这是真的有可能的。那为什么避免这种情况？

王艺辉(01:17:49): 这里其实还会有一个 agent 去 review 它的这个东西就是我提到那个 supervisor 它本身还会去 review 它的一个实现。另外就是你真正跑的过程当中，你最开始是要给他一些比较好的架构的，就是这个确实就不是纯启发式。我现在启发式主要是用两种一个叫5Y，我会让他每次问自己五个问题，从不同的方面问自己。

Quanzhi Fu(01:17:54): Ok. 

王艺辉(01:18:14): 五个问题，然后选五个问题之后，再通过那个 swot 让他去从那里面去选，就让逼迫就他每次选策略这个动作，他就会去经过两轮的这个反思，逼迫他不要去选一个，就是说写 if else 就选出写 if else 这个策略出来，如果他的他现在要实验的这个策略是 if else，那这个策略本身就失败了，就不用再去尝试了。不会符合预期的，他必须要去用一些启发式的。方法对这个系统能力有提升的策略，才会被我通过去进入到实验流程当中去。

Quanzhi Fu(01:18:46): OK 就是还是需要一些 prompt 或者架构上的东西，就比如说可能要调一下 supervisor 和这个我本身的 agent prompt 都要有比。

王艺辉(01:18:55): 首先是 supervisor 是对最后的那个结果进行负责，就 supervisor 是最后改完之后的。然后的那个是他每次进入到那个迭代流程就进入到流 loop 之前嘛，他会去选一个策略就测这个策略是他自己 plan 出来的，这个 plan，就会你会给他一些方法论，让他去想我现在选的这个策略是不是符合我这个长期规划的，就真的能提高这个系统能力的，而不是一个 hack 的方式。

Quanzhi Fu(01:18:59): Ok. 

王艺辉(01:19:20): 他选完了这个策略之后，会拿着这个策略进入到 loop 里面。

Quanzhi Fu(01:19:27): 我感谢感谢分享！

王艺辉(01:19:31): OK 然后我再看一下下面的马工也提到说吉他之前起效这是一个很有好的。

Jun-SF(01:19:36): 小辉能听见我说话吗？我也想问一个 followup question，其实刚才你跟 Player 提的时候，我也都想插一句就是我把我问题打到那边了，就是我最后那个问题是我的。

王艺辉(01:19:47): 好。

Jun-SF(01:19:50): 其实你刚才也有提到了，但是我不是我们是想的一，但是确实是我现在碰到问题就是说，我觉得咱们现在这个流程里面，它主要还是一个就是系统的，就是说你其实每一步还是比较确定的，当然里面有一些东西你是需要去 handle，但是，我就想说现在我们现在慢慢的做一些 agent 的这些流程，就这些流程在这里面可能。

王艺辉(01:20:14): Hmm. 

Jun-SF(01:20:16): 它不是说一个 bug 要 fix 本身可能就是两个东西，一个是这个流程，它本身可能就会有一些分支，什么什么的，就是这个东西，你事先你是没法说的，它是在执行当现的？

王艺辉(01:20:26): 对 Hm. 

Jun-SF(01:20:28): 他这个回答，你就把它当成是一个对话，什么这个回答，他也不是说是一个怎么确定的回答，或者说他给你一个什么样的结果，而是说你们之前可能。你有个协议，比如说你，你把它想象成说我们让这个 AI 来执行一个流程出现什么情况，你怎么弄，然后你应该用什么知识，所以这两个东西都是不确定，所以在这种情况下，我们要调这个系统，就是说去。

王艺辉(01:20:51): 对。

Jun-SF(01:20:57): 看这一步是 accessible 就是我去定这个东西，我也不是说你这 bug 你给我 fix 了，而是说我针对你给我的这些东西，我看你有没有遵守我这个协议，我里边这些有没有一些可以调的东西，这个东西目前？有些东西是人工做的，那你刚才提到说我们是不是甚至可以考虑说多改些日志，或者我甚至可以加一个这个 agent 再进去让他看到这些结果以后再输出一些东西，我觉得这个是合理的，但是我还是想说这些是可以做到的，但是我怎么样让它闭环起来，就是说现在我自己这个流程，我用你的 loop 来以外的话，我的 agent 也加进去了，最后我出来这个结果，我怎么样判断说是。

王艺辉(01:21:31): Hmm. Hmm. Hm. 

Jun-SF(01:21:46): 说，你能不能生成一些，我可以调一调，还是说我这个流程出现问题，我怎么样有这个东西，最后我怎么能帮到我，而不是说我最后还是自己虽然拿到了很多东西，那相当于我自己就是自动化帮我做这些测试，但是我还是看这个东西没有办法回去。

王艺辉(01:21:50): 对你来，你可能你现在明白，我理解你你可能困惑的是说你这个东西没办法量化你的标准没办法量化。

Jun-SF(01:22:12): 一个是再一个就是说我收集了那么多信息，我能不能再设计一个什么办法让它自动去调整，比如说我也别就是最后出来一些东西，然后我再一个去调，我怎么把这个东西自动化，这样我的效率就可以提高。

王艺辉(01:22:20): 明白是这样的，我们这边，比如说我现在做的这个东西，其实在线上还有另外一个叫 APO 就是自动 prompt 优化这个可能是比较，这个是更成熟的领域，就是那个自动会优化这个，比如说某个客服的回答这个 prompt 的 APO，这个东西，其实比如说我现流程，虽然我现在这个流程指标是比较确定。

Jun-SF(01:22:36): 对。

王艺辉(01:22:51): 我其实是希望他能学习到人类思考的方式，就他标注的那个过程并不是一个纯事实的过程，并不是说我一加一等于二，他把它标出来，他需要去回答检查一些这个包括不是那么宽泛的表达风格上面的问题，比如说我们现在这个线上的系统，我们希望他对消费者，是比较热情的，或者说是比较那种，既带有科普知识的，但是又不是那种特别严肃的。

王艺辉(01:23:17): 那么这么一些细的东西，是我们是希望他能学会的，就 aa 技能学会的，那这个东西现在我们做法是说标注的时候，会有一个这个 reason 就是人工的 reason，然后这个人工的 reason 会适当的让那个模型就在他分数低的情况下，会透露给他，让他去进行一个白盒化的学习，他会学习到这个人工的 reason，然后把他自己再融入到自己这个 prompt 当中去。另外就是说他如果是就这个东西，我个人认为他还是需要去量化的，就不管你的标准有多宽泛，还是需要去量化，虽然我打分可能也不准就人工打分可能也不准，但是如果你没有量化的话，那模型它在 loop 里面，它迭代的指标，它就不确定它不确定要往哪个方向去走。所以我们这边即使是那种情况下，还是会给他去打个分之后，他在他分数低的情况下，他会去反思完之后，他如果真的找不到，他会去找，就是现在的他那个迭代里面那个 agent 的这个思考的这个过程，他会把他那个思考过程翻出来，然后跟人工思考的那个 reason 去进行一个比看有没有能提升的地方。

Jun-SF(01:24:20): 下回你回答我一个问题了，判定，那我知道了还是要往量化的方向走，那你刚才讲的那个什么什么回应，更加友好，什么什么那个东西，你如果标注放进去的话，你的输出是什么？

Jun-SF(01:24:37): 你输出的东西是什么？

王艺辉(01:24:39): 我们的输出现在其实这个东西是分为首先要有个 reasonreason 之后，它会把这个原句 statement 也会给到出来。原句就是 state statement 就是那个模型在最开始它输出的那个东西，然后 statement 给出来还会给一些启发式的关键词也是人工标注的，然后基本上是这么一个数据结构就 statement phrase 然后 reason，然后还有一个分数，这44个字段会给到模型。

Jun-SF(01:25:09): 是放到什么时候有点像是一个 evaluation 你你这是一个单独的过程，然后你你把这些东西做好了，然后是一个学习或者调整的一个过程，是单独的跟你的这个流程的这个开发是分开的是？

王艺辉(01:25:24): 你说的流程的开发是什么？就是我现在说的是我做的，你可以认为是 verifyagent 就是 verify agent 这么一个构建的过程，就是这个 agent 它本身是一个，它是一个多 agent，它不是一个单纯的一个 problem 的 agent，它是一个比较复杂的，它是一个系统的 agent，就这么一个系统的构建过程。

Jun-SF(01:25:30): The. OK。现在东西在你的就是整个的软件，这个 agentbuild 调试 verify，然后优化的过程中，它是放在哪个位置上，你刚才说的这个。

王艺辉(01:25:54): 你说的是 V 本身放在哪个位置上吗？

王艺辉(01:26:00): 这个 verifyagent，它是一个后置的就是我线上有线上的这个服务，这个用户的 agent 对，然后他会不停的去把线上的这个语料拉过来，然后线上的语料会经过人工去处理，人工会可以给它处理成这个 agent 能被消费的这个我刚刚说的一些技术的这个格式，这个 agent 就会消化这个线上的这个语料，把它内内置到自己的这个系统当中去，然后再用这个 agent 去提升线上系统的那个 agent 的效果。

Jun-SF(01:26:06): 就好多时候都一直都可以用的？是，所以你这一步都已经放到那个 monitor 或者是 operation 的这一部分，是你这样是一个持续的一个一个改进的。

王艺辉(01:26:36): 各位。它是一个持续的过程，所以这个东西是特别需要自动化的就是你你靠人的话，其实坦白说，如果你靠人的先验知识，尤其是我们这边还是比较吃业务的嘛，有些业务东西吃的还比较重的你靠你请精算师过来，你让他去在这里面干一个礼拜可能比你自己跑两个礼拜是要效果好的，精算师不可能一直给你干的。

王艺辉(01:27:01): 这个东西它是不停的要学习的，你必须要把整个学习的过程给它做到全自动化。

Jun-SF(01:27:07): 所以 overfitting 的话，你你们现在这套实用的性还是比较高的，就是目前的话是满足你们需要这部分。

王艺辉(01:27:14): 对目前还可以，不过确实是会有过拟合的情况的，所以这个东西是还是一直在调整，他确实会有过拟合的这个 hypothesis 情况，尤其是怎么说？

Jun-SF(01:27:20): 一直在调整是。

王艺辉(01:27:28): 可能不太好，反正就是有些国内的模型就确实会 hypothesis 的情况会更严重，就是相比。

Jun-SF(01:27:36): 谢谢。

Ryan(01:27:37): OK OK 我那我接着这个问题，我作作为一个第三视角的来看待这个问题的话，就刚刚我们说会有一个独立的 agent 去做那个端端端这个 loop 里面去限制他说他怎么样去按照一个更好的标准去做，然后那么这个本身他做 verifi 的这个 agent 是由于我们人去做他的本身的另外一个怎么说？验证 a 这个 agent 我们人是在不断去优化验证 agent 它本身这个 agent 的它一个标准是吗？

王艺辉(01:28:13): 这个需求就首先要线上的那个 agent 也是我负责。然后我这个 vragent 也是我负责，就是我现在是开发一个 agent 去帮助我提升线上 agent 的这个效果。就我现在要开发一个 agent 帮助我提升线上这个 agent 的这个效果。然后我现在就是提升这个线上 agent 的这个 vera agent 它是一个自动化构建的 agent，然后线上这个 agent，它那个 agent 其实最开始是我自己写的。

王艺辉(01:28:38): 那个 agent，其实你你你可以认为那个 agent 相当于说他的评判标准，不确定，就他在这个微软 agent 出来之前，没有人给他评判，他说这个流程跑通了，他能回答问题了，但他回答的，其实没有人给他评判，所以我现在去再去做另外一个 agent 去评判他。但是我为了评判他的 agent 足够权威，我要把这个 agent 本身这个能力提上去。

Ryan(01:28:53): 明白了，其实这个想法还是挺好的，就是用一个 agent 去代替自动化流程里面人类的那个工作，然后人类在动态的去调整我在地态人类工作的那个 agent，让他去让他知道执行标准怎么样去做的更好，然后让他以这种高标准的方式去限定我们在自动化循环，也就是说在 loop 里面去处理的本身 agent 的标准。

王艺辉(01:29:08): 对。对。对就本身那个键，你可以认为他其实就是相当于是说，我现在是真正有一个系统能不停的承载我这个业务的诉求了，而诉求不是存在于某个人的脑子里，不需要人去投入，就我们通过流程的方式，把这个业务对这个线上的回答的要求？或者说一个什么响应的表述的要求，把它不停的能沉到沉淀到这个系统里面去。

Ryan(01:29:25): 这样的话效率就会提高很多，因为它这是动态的明白。

王艺辉(01:29:52): 就沉淀到这个 VR 系统里面去，然后这个系统，它来代替人类去优化真正的线上服务。

Ryan(01:29:58): okok 明白了，那当时刚才我还有一个问题就是比较偏激的一个问题，当我们所有的测试和自动化测试都做，都让 AI 去自动化执行的情况下，那我们本身作为我们在公司里面的这个测试人员，我们的角色应该发生怎么样的转变。比方说我们之前，所有的测试用例，按照我们现在比较经典的软件做法。测试都肯定会先出测试用例，然后再进行测试用例评审，然后最终再去根据测试用例去进行测试嘛，那我们后面的话我们在就是我们按这个话题进行展开嘛，我们后面的话，我们如果还保留着这些测试人员的情况下，我感觉您看一下，按以你的视角来看，测试人员的工作重点应该放在哪些位置？

王艺辉(01:30:35): Ok. 是这样子，我最早就是去年就有一个看法，我就觉得这个东西后面这个工种之间的界限会被打破掉，就不管是前端后端还是测试，包括算法，他们可能都会除非一些比很专业的，比如说你现在你是真的去训大模型的，那你可能本身你的这个水平是比较高的，那你是还是专精的，那对于大多数的以前的所谓的前后端测试开发这种来说。

王艺辉(01:31:12): 我觉得他们会被融为一体，他们会这个部门墙会被打破掉，因为模型可以写所有东西，他也拥有基本上你就可能有些知识你是知道的，但是大部分知识你是还是没有他会的部门墙会被打破掉，然后今年不是最早的时候，我看前前两周吧，不是那个碧泉，还有就是 focus man 还是 API Focus 就他们那些团队。有一些基金的做法，比如说我们所有的工程师都要转一线的工程师，然后现在我在的公司就是也有这个趋势，就是从上面的老板上面也会有这么一些考虑在这里面，从从这个大方向来看，我觉得以后测试的话，包括我现在的这个团队就是去我比如说那个测试标注的工作，还有一些细碎的工作可能是测试在帮我做的，他们现在可能做这些工作，我觉得长期来看。他们还是会逐渐的和跟我一样的角色，就是我会去 O 这个系统就他可能 O 的是这个测试模块，比如说这个微软件我做好了之后，可能我会交给他，就现在这个流程我已经把它优化的差不多了，那可能后面的这个维护工作，这个一些迭代工作可能我会交给他，但他会去 O 这个系统，它不单单是一个单纯的以前测试这个角色。

Ryan(01:32:26): 也我们的工作边界会变得模糊，但是实际上我们在专业领域上面的话，应该会需要更加突出去进行一个关键性节点的维护了。

王艺辉(01:32:38): 对这个节点其实我觉得从职责上来说是不一定有变化的，比如说他虽然是他以前是测试，他可能是验收这个你开发的功能是不是符合这个原本的这个产品的预期，他可能是验收这么一个东西，那么他现在同样是验收，只不过他验收的是 agent 的这个行为，但这个验收 agent 的行为，说不是需要他自己手手手点点点的这个方式去做，他需要的是开发一个 agent 帮助他去点点点的方式去做。或者说更高级的开发让他去评测，那他要做的工作是开发这个 agent，但他的，但他负责的内容依然是类似于测试质量验证这么一个事情。

Ryan(01:33:15): 明白了，就是在自己的领域，然后让 AI 去更好的去做这么一个工作，然后得到一个更好的效果，比方说去做那个用户用例审核之类的东西。

王艺辉(01:33:23): 对我个人这么理解的。

Ryan(01:33:28): OK OK，这个我跟我的想法其实也是类似的。那我们其他还有什么其他的问题吗？因为现在参会人数也蛮多的。

Jun-SF(01:33:37): 然我想补一句，因为我只是一个想法，就是第一个就是你问这个问题之前你其实跟那个小辉说，我们刚才那个刚才我们不是讨论一个流程嘛，说这样可以提高这个效率，其实我觉得我自己的感觉是秀，其实我觉得那个东西效率能不能提高，其实是在于说你之间的这样的一些评价指标，或者什么什么能不能定义出来，然后能不能闭环，我觉得其实是没法说，目前还没法说。

王艺辉(01:34:02): 对。

Jun-SF(01:34:07): 那么再往下走，就是说你刚刚说的这个弱，这个部分，我只是想发表我的一个观点，我想 clarify1下就是说刚才小辉说的是说，有可能这些人员就去维护这个，其实我觉得维护这个也不好说，因为以后的维护的工作量其实也不明确，但是我喜欢小小辉说的那个 O 的词。

王艺辉(01:34:14): Hm. 

Jun-SF(01:34:32): 那 old 这个词到底是什么意思？我觉得大家在自己的工作区域有些重叠，也可能说大家还在自己这块，但是我觉得人都会往上游走的意思就是说都会去想办法去定义。比如说测试人员，他做的工作就不是在执行端，他可能就是说去定义一下什么是可评估的东西，那以前可能是我们的逻辑是这样子的，那以后发现在运行**现新的问题了，或者什么什么的，他可能。

Jun-SF(01:35:03): 这个时候他可能就需要去想，那我要重新定义一下这个问题以后那么要做哪些开发他自己要去开发我觉得小辉说的可能是这个意思。

王艺辉(01:35:13): 你觉得他更多的他已经变成了自己测试驱动自己，他发现问题之后，他自己就可以解决掉对吗。

Jun-SF(01:35:14): 我就我。对，然后人的工作说就会一个反思性的工作去想我们这样做事是对的吗？是配合到其他的这个其他的环境嘛，模块嘛，就人就会被不断的 push 去思考这样的问题，因为你执行端的东西交给 AI 来去做。

Jun-SF(01:35:40): 但是这个定义的这个过程是很多很是很复杂的，是可以反复去拆解的，而且你是要去根据你的这个业务在不断的进化。

王艺辉(01:35:48): 我也是同意的，有时候定义一个问题才是最难的，这个东西到底怎么怎么做，反而是其次，然后我还想交流一下，就你刚刚最开始提到说，你觉得这个流程的效率不一定提高，因为可能卡点在于说这个指标能不能定义清楚，这个可以再详细展开说一下您的看法吗？

Jun-SF(01:36:12): 我不知道有没有时间了，因为这个东西就要把一些 context 讲出来了。我们要不就对我们可以线下交流对。

王艺辉(01:36:18): OK 没关系，私聊一下，没关系好的，对我觉得这个可能你经验还是就还比我还是要丰富的。

Jun-SF(01:36:27): 我只是一个 general 的 general 我感觉这块是痛点。

王艺辉(01:36:37): 好的。

Ryan(01:36:39): 那这个问题，我们暂时先讨论这些马工有什么 OK OK OK 马工？

马驰(01:36:44): 我有个问题，请教一下，就是你你说的集成测试可能会退化为单元测试，也可能比如说如果全部 mock 的话，全部使用外部依赖的话，就会变成端到端测试，那你你你自己在这种分层是怎么做的你你就说把直接把集成测试这个去掉了吗？

王艺辉(01:37:00): 对。

马驰(01:37:07): 你你们怎么就或者我就说你怎么分类？

王艺辉(01:37:09): OK OK，就这个我的看法是说尽量的去 mock 掉所有的线上的行为，就是我刚刚介绍的时候举个例子吧，比如说我现在要去对接下游的，假如说银行的接口，那我他我拿到他给我的规范之后，我就让 AI 去按照他的规范给我本地起一个服务器，我可能本地去调他的结果是调不通的，我没有他的那个 os key 嘛，或者说我。

马驰(01:37:34): 对。

王艺辉(01:37:37): 网网站根本就是不通的，那这个通常来说，在以前的做法情况下，可能这个东西我只能 mock 了，就是我会写代码写点 mock。那现在的做法可能是我让他直接在本地取一个 GDP 服务器把这个把他的接口给拦截掉，就是我对于我的 aaia 来说，他跑测试的时候，他是不感知的，他以为他调的就是真实的接口。

王艺辉(01:37:57): 就是我现在的做法是这样子的就是我有什么就能 mock 的我基本上全全把它给 mock 掉，但是这个 mock 是按照这个规范去 mock 的，并不是去随便写一个测试用例，就比如说随便写个123就按照他对方，我期望对方能给我发来的东西去 mock 然后我认为也算是端端端测试，因为我其实对我现在跑的 agent 来说，它所有的环境是真实的。

马驰(01:38:23): 那你 mock 你，你本身要 mock1个第三方服务，那你这个 mock 本身的行为怎么怎么控制，比如说有时候你想要它超时，有时候你想要它返回404。有时候你想要它返回200？

王艺辉(01:38:35): 对。这个就比较精细化了，有可能你看你你的成本了，就是你现在 AI 的话，它是可以帮你写一个比较简单的服务器的，然后你比如说你，你甚至可以稍微去加一点 hack 比如说我传某个字段的时候，我希望他就在那个接口的行为能给我返回什么，就你可以自己去给他提点要求你在测试的时候，你可以有环境变量去控制这个东西。

王艺辉(01:39:00): 就是你在就是因为你我现在是默认这个服务嘛，这个服务的行为全部由我控制的，我只要保证 agent 在跑，他跑那个测试的时候，他返回东西，是跟我预期的是差不多的，就是我现在预期他返回的是500。那他就是我可以通过某个环境变量就再比如说我在我自己让 agent 触发也好，我自己现在全局设置一下也好让他能触发到他那个东西确实能返回500就好了。

马驰(01:39:04): Sir. 

马驰(01:39:24): 我之前用用了环境变量，后来我改成了就是一个 httphead，但是对，但是 http 后来发现也会搞得很复杂，因为我想要的行为比较多，然后还有那种就是跨 http request 的请求，比如说这个请求的行为应该依赖于上一个请求所带来的，比如说一些信息，它其实是有状态的。

马驰(01:39:49): 就感觉有很容易就把自己搞糊涂了，我一搞糊涂，我的 H 也会搞糊涂 Thank. 

王艺辉(01:39:51): 就感觉你这个是因为你你的你的上下文耦合比较就是上下游耦合比较多，就是你可能你要同时冒个好几个服务，并且是好几个服务之间的信息传递是有依赖关系的。

马驰(01:40:07): 对比，比如说一个银行，假设我比如说我上一个请求里面，我没有带一个 scope，我没我的权限 scope 里面没有说包含银行流水，那我第二个请求我去请求银行流水的时候，我就应该会得到一个403。那这个也就是说我的 mock 银行应该返回一个403，但是什么时候返回，403什么时候不返回，03是取决于上一个请求，所以对，所以这个就现在让我很头疼，就是我会搞得很复杂，然后最后我自己都不知道这个就是究竟的行为是由什么决定的。

王艺辉(01:40:37): 我明白你意思？

王艺辉(01:40:52): 明白的话，你的测试用例就会就是对于你 mock 的服务器来说的测试用例就会维护起来就会比较多了，就像的，其实这个说我不清楚你有没有写那个像 usecase 就是你对你这个 use case 可能拆分出来会是有好好几十个的，对正常对于你的一个 happy case 来说，可能就是付款，然后什么结束了回调，然后就结束了，但是可能你你考虑到。

马驰(01:41:00): 对。Sir. 

王艺辉(01:41:17): 这个异常的边界的这个 case 的 usercase 可能会有好几十个，就，但我觉得就是看情况吧，相比于联调的成本就到底是怎么样，就如果联调成本比较高，就可能还是值得的。如果联调成本没那么高，就可能还是直接就联调，就那还是要走传统的方法，联调就看 ROI。

马驰(01:41:36): 对对我，我做纯的那以年计算了。

王艺辉(01:41:41): 那就没办法，那还是值得让 AI 去一下，可能是反正我现在做法就是说，把 user case 梳理清楚之后，那尽量的去吧。

马驰(01:41:51): 谢谢！

王艺辉(01:41:54): 没事。

风之泪(01:41:58): 你好，我想问一下，比如说单元测试也好，或者是这种集成测试也好，就我们怎么去衡量 AI 生成这个测试用例，它的覆盖面是全的，然后那个就是因为它会生成很多嘛，那我怎么知道它生成的这个是 OK 了，就不用再生成了。

王艺辉(01:42:19): 明白，首先它这个传统的 AI 它这个里面会就测试里面它会有一些覆盖率的统计，不管是这个分支覆盖率还是这个行覆盖率，就本身这个你是你们平台的话，或者是你自己本地跑起 coco 也是可以看到的，不过现在我其实不是很看这些东西，我关注的是我自己理解的用户的动线是不是被覆盖到了？

王艺辉(01:42:45): 我更关注的是说这个行为就哪怕是或者是个接口吧，就我不是说从前端开始，就是因为后端的这些行为就起码我自己能想到的一些用户的行为，它应该被覆盖到。

王艺辉(01:42:56): 我关注的是。

风之泪(01:42:59): 我们那个单元测试的覆盖率，其实那个数百分比，实际上我们也在不断提升，可能前段时间写了60%那我们就提升到80%但是这个东西你就你没有 AI，你也能花时间也能把这个覆盖率给提上来，那我们现在有了 AI 就是提高更快，那我们怎么衡量？覆盖率上来了，那就能一定代表说我。最后中交付的结果就是越好的吗？

王艺辉(01:43:27): 这个不一定尤其80%其实还不算高，真不一定就是它的覆盖率和你的这个质量就是代码质量一般是成正比关系的，但是很多 cornercase 就是恰恰就是因为你测不到，比如你现在去举个简单例子吧，你可能测一个单元测试你单元测试里面，假如说你这个本身这个依赖的耦合的这个上下文的这个变量比较多，然后可能 if else 比较多，你可能单从这个行覆盖。

风之泪(01:43:31): 对就即使再往上提，就我们再花时间提到，比如说90%几。

王艺辉(01:44:01): 概率来说，可能是很快就能达标的，但从分支覆盖率上来说，你可能就几乎达不了标，因为你本身耦合了很多上下文变量你都没办法去摸它，因为你要你改上下文，可能你把其他知识也改失败掉了。

王艺辉(01:44:14): 像这种情况下，我个人觉得就是我还是希望把它放到一个更大的模块里面去测试，而不单单是测试它的功能，可能说我当然会保证它的功能是用，就是就我不一定会说看这个覆盖率去保证覆盖率就是有测试团队，他们有些卡点，他卡点，比如说现在定了80%，那我能达到就 OK 了，我不会去看，我看到的是我到底期望他的一些。需求就是我最开始那个里面放的就是你写一个赞的话，比如说我现在我应该抛出异常，当它是 pop 的时候，就类似于语语语义化的这种表述就是我现在做的这种语义化的表述。我希望这种表述，它全面了。就我觉得，但这个还是一个相应的标准，这个它全面了。然后我就认为它还算 OK。

风之泪(01:45:02): 还是人的主观的衡量多一些。Huh. 

王艺辉(01:45:06): 这个是可以，你让 AI 拆分的，但你你判断它是不是就是 AI 拆分完之后是不是 OK 了，那这个其实还是看个人经验，就你对业务的理解了，就本身你们业务可能，哪怕同样的入参可能会不一样的行为，我觉得也是有可能的，在不同的时刻，就假如说业务是，是这样的，比较恶心的一个情况的话，那你肯定是要这种情况，你要也要照顾到。

风之泪(01:45:29): 然后我看你就是 UI 那种测试就是也是用那种你自然语言写完了之后，比如说打开一个页面，然后出现了多少这个，比如说搜索的结果或者什么的，但一个页面它可能对应很多的这种功能，或者是就如果说按照 API 接口的话，它可能有很多的 API 接口去组合回来，它有的时候。

王艺辉(01:45:39): 对。

风之泪(01:45:54): 因为你你去描述那个场景，我感觉我们测的时候就有的时候它因为页面上的东西太多了，就是它可能加载一个这个信息，那这些东西怎么去写这个你这个测试用例，然后让它测的更全面，因为有的时候就感觉那会写很多。

王艺辉(01:46:14): 明白，你们那个页面是我现在做的是这个 a 的平台页面，我的这个整体交付其实没有那么多，然后如果是那种传统的 B 端的或者 C 端的那种大量的，比如说你像假如说你现在测一个淘宝的页面，那它里面的各种各样的买点可能超超级多，那这种情况下，你可能就不太适合去走 UI 的层面上的端端端的时候，你可能还是得看着一下你自己。

王艺辉(01:46:43): 确实关注接口。

风之泪(01:46:47): 好。

Ryan(01:46:49): 这方面我还是有一点经验的，因为之前我们那个群里面那个薛老师之前他也是针对于复杂 UI 测试也有过一些分享的他是想法是也是前端分层，然后前端类似于后端一样也是做分层，然后一是前端模型或 service 类似于我们后端的那个 MVC 嘛，因为因为 voe 和 react。我们就可以进行，认为它是一个 mcmac 的架构分层，然后它也是针对于前端进行多端分层之后，然后每一层进行 mock 测试通过之后，然后我们再去找去 UI 测试。刚刚说，小辉分享里面的时候说的是 chrome 它本身用的那个 develop to 去做测试，然后我之前用了一个叫 play right。它会去根据可见数去做一些减值性的东西，比方说你页面加载了过多复杂类型的东西的时候，你就不需要去考虑那么多，它就是把可操作的可见数，然后去让 AI 去理解它会拿到对应的可操作数，然后根据你的测试用例的一些自然语言描述，然后去分析我应该去点哪些功能，去测试哪些功能，然后我当时是做的是把。

Ryan(01:48:04): 所有的测试都做完之后，然后会冗余下来。它每一个测试用例对应的测试脚本就是一个类似于监测脚本或者你自己定义的那种样板格式脚本最终会输出一个测试报告，比方说我针对于当前一个复杂性页面。测试用例有多少，然后测试的过程是哪些，然后测试的结果是什么，然后针对于结果的分析就是我们怎么去判断一个结果分析，当时也是首先 play 去判断我当前下一步骤应该出现什么问题，比方说我加了一条数据，那么去读对应的 table 或者 grade 当中是不是有这条数据去判断一个结果的行为是否正确，当时也做了一个比方说。

Ryan(01:48:45): 类似于一个视觉模型的分析，就是在关键性节点的时候让他去截图去截当前浏览器这个 tab 里面的一个屏幕截图，屏幕快照，然后去做一个结果分析，是不是能保证说我当前的测试是对的，我之前的一个方案是这样的，我不知道能不能。

王艺辉(01:49:06): 这里我还有一个细节，就是我也会让他做一些这样一截图，然后就会发现他有时候截的图太大了，他很容易读一下图，就把自己上下文撑爆了，你们有碰到过吗？怎么解决的？

Ryan(01:49:17): 我读图是 OK，我称报的时候称报上下文有两两种不同的模式，一个是我刚刚说的，为什么我去尝试做这个东西，因为我们公司的那个架构比较老，说实话，它是服务端渲染的，它是输出出来的，是所有的都带 shadowroot 的，然后就导致我直接用 play 去读的话，它就上下文就贼大，就是它会出现各种。

风之泪(01:49:18): 我也遇到过。

Ryan(01:49:43): 超级多的一些垃圾数据去污染我的上下文，然后我这种情况下的话就是用去截图是用第三方 agent 就是第二个 agent 去做分析，就是把它作为类似于 class 里面那种 subagent 的概念，然后把图单独去扔给另外一个 agent 给它分析出来，把我要的结果和要的结果作为一个提示词，然后去放到同时放到第三个线。

Ryan(01:50:08): 另外一个线程里面去做处理，去让他另外一个线程去判断我当前，然后给我一个结果，然后去做图的分析，比方说它会返回一个图图里面的信息是什么，会有一个类似于什么，我当前图有哪些功能就是就像人的那种可视上的去判断的一个想法是另外一个技能去做。

王艺辉(01:50:26): OK OK 挺好的，你这个行为的话是通过提示词控制的吗？挺好，可以。

Ryan(01:50:31): 对我当时是全部用提示词去做控制的。也是一个想法，就正好也提到这个问题。

王艺辉(01:50:39): 这个挺好的，因为我之前我的做法去我的做法让他结完之后发现他经常会报，所以我可能就会让他去结部分就是一个比较妥协的办法了，那确实是说。

Ryan(01:50:50): 其实你去截部分的话，其实不是很好控制，因为它本身它是没有视觉判断的。

王艺辉(01:50:53): 对就不是很好控制。对我只能告诉他在某个区域嘛，所以你这个方法我觉得挺好的，用一个职业竞争的方式去再去解析它挺好的。

Ryan(01:51:02): 你去丢在另外一个 agent，然后让另外一个 agent 把分析完的图片和你输入的那个提示词去做一个结果，然后再回来，让他去判断对还是不对。

王艺辉(01:51:12): Ok. Ok. 

风之泪(01:51:14): 我刚才听你说的。

Hsberg(01:51:14): 你好，我请教一个问题。Wait. 好，你好，就是我刚才听你说，就是你们的有一个实践，就是说你们可以把基层测试的外部系统或者外部模块，用 AI 写一个 mock 来做基层测试，然后这个我之前也想过，我后来想到它会不会相当于是把我们要用把 AI 的。

王艺辉(01:51:21): 好能听到。

Ryan(01:51:23): 你你那边你先说。

王艺辉(01:51:35): 对。

Hsberg(01:51:44): 不确定性转移到这个 mock 这个模块上了，就是怎么样保证 AI 生成的这个 mock 它是可信的，因为如果 AI 生成的 mock 不可信的话，那我们用这套这个系统测出来的结果就是也是完全不可信的，因为这个 mock 的行为可能完全跟外部的系统完全是不一致的。

王艺辉(01:52:02): 明白就是可能用一些契约的方法就 OPEN API，或者说没有 API 的话，至少它得有一个相对规范的接口文档。

王艺辉(01:52:16): 就相当于是他定义接口的时候应该给到我们，然后我们会按照他定义的东西去。

Hsberg(01:52:23): 就比如说有些接口它内部是有些状态的，就它的内部的状态会根据你，你上次请求不一样，它会返回一些。它内部也是有一些状态的，有可能接口和接口关之间也是有关联的，那就相当于这种情况。我去 mock 的话，就相当于是也去把它自己去猜测他们内部系统内部是怎么运行的，但这样去 mock。

王艺辉(01:52:40): 明白明白。明白这样的成本就太高了，就我觉得就跟刚刚马工提到的就有点像，就我觉得就其实我们并不是要实现它那个系统，我们是要实现这个 case，所以就我个人的做法就是可能说梳理出那个 case，但是我现在可能没你们复杂，我觉得可能做法很类似，就是还是梳理出 case 按照 case 的方式，你哪怕在你的那个服务器里面。不管是环境变量还是说其他的方式，就只要能保证它在对应的 case 的情况下能返回。

马驰(01:53:26): 我可以补充你补充一下，就是我不太赞同说你一定要完全复制他的行为是不可能的，那相当于你你你要重建一个银行系统，或者说任何一个你想要 mock 的系统嘛，那你的主要的成本会成为你去构建所有的依赖项目的，我只我现在的想法是。是我要尽量模拟这个依赖被依赖项目的行为，但是这些行为不会覆盖所有行为，我只会覆盖我想要测试的行为，因为我是很清楚我要测试哪一些哪些 scenario 的我比如说我要测试我的系统能够处理403能够处理，比如说分页，那我就会在测试用例开始之前就告诉这个。

马驰(01:54:18): 系统你要模拟，比如说分页，你要模拟403你要模拟404那这样的话，我就其实我很清楚，我要投资在这个系统上多少，如果你一开始就是说我要做一个跟被依赖项目完全一致的项目，那你会发现你的重心从你本来要实现你的 system under under test 变成你要你要。星球变成那个依赖系统了，那依赖系统如果本身又依赖于另外一个系统，你就无穷尽了。不过这个问题是，一个也是我目前碰到的就是比比较真实的问题，因为我觉得生产系统这样做。刚刚才小辉也说了，就是你要有契约依赖，我看到的两个挑战是什么？第一就是银行有些 API 它是不完备的法律，我在欧洲要求他必须要提供 API 它是。

Hsberg(01:54:49): 理解！

马驰(01:55:17): 被迫要提供 API 的，所以它的 API 的质量就不一定那么可靠。比如说它的版本可能没有及时更新，或者说它有的那种动态 API 就是没有提供详细的说明，这是第一点。第二点就是即使它提供了完备的 API，我也要去确保我的 API 确实是完全是就是我的 API 的在。实现是符合这个契约的，这也是一个工作，我很难说有一个比较通用的方法，但是我觉得往这个方向探索是会很有价值的。

Hsberg(01:55:57): M. 

马驰(01:55:57): 这样的话，我就可以把整个就把整个质量控制，从系统本身扩展到系统依赖上，然后我们在生活中，比如我在实际生产中，你你就大大多数人生产的时候，并不是说做一个像一个像 APP，就是说完全独立的，大大多数人都会有非常多的依赖项解决这个问题，我们是可以把 icode 从做一个独立的 APP 扩展到做，在巨大。

马驰(01:56:29): 系统中的某组件。

马驰(01:56:36): 我觉得我们甚至可以以后再组织一场一场专场就是我们讨论就是对依赖性的测试，尤其是那种你不可控的依赖性的测试怎么做？

Jun-SF(01:56:52): 我喜欢这个题目。

王艺辉(01:56:54): 挺好。

Ryan(01:57:01): OK 就还有刚刚好像对还有哪些新问题吗？

马驰(01:57:05): 还有好几个问题？

王艺辉(01:57:08): 还有吗？我看一下。是那个群里面聊天那个里面，我看好。

马驰(01:57:15): 对聊天里面。

张熙(01:57:18): 你好，我想打断一下，我想问个问题是这样子的，我刚。

马驰(01:57:22): 我打断一下你吧，大家如果提问，如果你跟嘉宾都提问了，最好打开摄像头吧，让嘉宾知道谁在问？

张熙(01:57:32): 我在问是这样子的问就是在基于现在 AI 生成代码的情况下，怎么保证那个 gwt 跟生成的测试用例是对等的是这样子的，因为我之前一直写那个红绿循环嘛，那基于我自己写出那个 gwt 的时候，我写的测试用例一般是不会漏的，基本上就是一对一这样子写出来的，但是我基于生成这个测试用例的时候，我就发现。

王艺辉(01:57:32): 没关系，不方便就没也没关系！

张熙(01:58:01): 会漏掉，尤其是这种生成测试用例成本比较低的情况下，我写了二三十个这个 gwt 我就是它生成漏了，我也看漏了，我就发现有这么一个情况存在，而且因为我只是做了 tdd 嘛，有时候去点工测试的时候我才发现原来这个功能我还没有做，到了这个时候我才发现问题了。你就想这方面有什么可以去补充的吗？

王艺辉(01:58:27): Ok. OK 这个我可能就还没有你权威，就是我平常可能也就写个十个左右的 gwt 我的那个功能可能就完成了，然后他怎么完备，就这个我确实我也不知道，但是他。

张熙(01:58:45): 是我卡了吗？

王艺辉(01:58:48): 那你能听到吗？

Ryan(01:58:51): 我这边能听到我这是挺正常。我能听到你们两个人对。

马驰(01:58:53): 我可以听到你们两个人。

王艺辉(01:58:57): 对就能听到吗？张熙，我看起来我感觉他好像可能听不到。

马驰(01:59:01): 我可以听到，我不知道那哥们。他可能断线了？

王艺辉(01:59:14): 他好像退了这个问题还挺难的，怎么保证是完备的。

Quanzhi Fu(01:59:23): 我觉得。

马驰(01:59:23): 没事，我们可以继续讨论回头他可能读一些读我们的 script。

Quanzhi Fu(01:59:31): 我感觉和代码是一样的，就是你既然可以 code review 你的代码和文档是不是 alive 你当然也可以做 test review 你的 jwt 和你的用例是不是 alive？

王艺辉(01:59:39): 不，你的用例是跟现实就取决于你的业务需求，这个业务需求有时候就非常的诡异，就不是，反正我目前我也没有找到一个方法说我能想到我的业务需求都被覆盖了。就写代码还不太一样，就如果我的需求是确定的，我的代码是可以完整覆盖这个需求，但是我的需求本身就不是确定的，就我没有办法保证说，我想到了这个充分的用力。

Quanzhi Fu(02:00:09): 刚刚的问题是 ggwt 没有覆盖，还是说用力没有覆盖到 gwt？

张熙(02:00:18): 不好意思，我刚刚卡掉线了，我一直没听到这样子的，我就是我已经写好了 gwt 了然后如果我人工写那个测试用例的话，其实他们是一对一的一点问题都没有，但是我现在写了 gwt 之后生成了测试用例，但是测试用例就是漏了，我肉眼看我也看漏了。

王艺辉(02:00:21): 没关系。

王艺辉(02:00:39): 那你 OK，你现在这种情况其实可以理解为说是模型的指令正确性不够强吗？按照你的这个。

张熙(02:00:41): 然后。

王艺辉(02:00:52): gwt 生成结果，比如说20个可能生成了19个。

张熙(02:00:56): 对因为现在生成成本太低了，我可能生成三四十个都有可能，然后你说我把它拆开来，十个生成为了保证他们对等的话好像。有一点浪费那个次数，因为我的 AI 是按照次数来的？

王艺辉(02:01:15): 那我觉得你我没有碰到这种情况，我只是提一下，我觉得你你你强你你要你要强制对等的关系上保证的话，你其实可以加一些 commit 的规则就是 commit 的 hook。Hook 是可以，比如说你你的你你从最起码从这个数量上来说，你是可以保证他们是对等的。然后我刚刚理解为我刚之前开始理解错了，最开始里面你说的是你这个模型拆出的这个 gwt 本身不完备，就本身你的需求可能不是那么完备，如果是后者的话，可能就通过一些 hook 的方式可以去保证。

王艺辉(02:02:00): 你好，现在能听到了，我刚说不能听不到有没有听到能听到吗？

张熙(02:02:03): Hello. 现在。

马驰(02:02:03): 它又掉了。

王艺辉(02:02:18): 信号确实不太好。

王艺辉(02:02:24): 没关系，没关系。

马驰(02:02:25): 下一个！

王艺辉(02:02:30): 我跟江西说一下后后面跟他聊，其实也我也没有给他太多帮助。大家还有其他问题吗？

leo(02:02:40): 我插一句，我其实插一句，如果他按次数做这个的话，我觉得就没必要搞 AI 了，这个本来就大力出奇迹是吧，一次不行就照样两次，不行就三次是吧，既然有空 review，所以测试用力也应该 review 用对抗性 review 就行了，然后测试用力。

王艺辉(02:03:00): 对，要么就 review，要么再加一个流程去 review 那只能这样。

leo(02:03:04): 对因为测试用例能有多少，三四十条能有多少跟大家写代码，写那些东西都不是一个量级，而且测试用例你写完一次之后，它会能沉淀成为后面的单元化，甚至回归的，特别是你那个 gwp 其实就是。

leo(02:03:23): 算是 uat 的一种，所以一次不行就两次，不行就三次嘛，反正如果是我，因为我是企业内部的那晚上的大模型都没人用了，我就跑十次，那肯定是准的嘛，再加一些规则，所以我觉得应该问题不大。

王艺辉(02:03:42): Mm. 

马驰(02:03:46): 另外的意思就是 saltalking 不 sorry talking 就要解问题解决。

王艺辉(02:03:49): 多就跟徐老师说的，他一个文档要 review10几遍，那就是大力出奇迹。

马驰(02:03:58): 他可能解决问题，何必再去动脑筋？

王艺辉(02:04:01): 你你你那确实是的。

leo(02:04:02): 对我都是这样子的，有就是不要将自己的那个智商跟精力浪费到烧 token 说真的，大家时薪也不低，这个你你现在的什么 kimi200块一个月是吧？随便烧去，这个东西，所以我觉得这个总比漏一个 uat 大家后面的返工的情况多得多，而且这个其实坦率来讲是一个语义比对，不需要智商的事情，何必花时间去焦虑这件事情？

王艺辉(02:04:41): 确实。

leo(02:04:42): 反正这是我的大原则！

王艺辉(02:04:44): 确实就我再补充一下，就比如说我现在做 V，它其实本质上它也是一个一个大力出奇迹的一个过程，说白了它要不停的去尝试各种的策略，那它其实就是并发的去烧70，24小时再去烧 token，然后换一个比较好的效果。确实就我感觉是因为他还得找。好。

马驰(02:05:17): 我看还有一个问题很有意思，达摩克利斯之剑提的重度交互的复杂前端业务页面。

王艺辉(02:05:20): 看一下。

王艺辉(02:05:30): 对重度交互的复杂前端页面有很多交互有什么比较好的 AI 自动测试方法需求迭代很快耗费时间设计测试性价比会比较低下一次测试的话上次就没有用了。这个其实刚刚好那个刚刚同学也提到了，对这个可能跟 rain 的想法，我差不多，我觉得我们可能这个的话就可能让 AI 去截图一下吧，截图看一下，如果说你本身这个页面很复杂，交互又很复杂。这个可能还真的不太好办，就我目前我也我的实际过程中也没有这种场景，不知道现场有没有其他同学能提供一些想法，如果真的是那种页面交互都很复杂的，这个前端如何测试？

马驰(02:06:21): 这不是 player 正在解决的问题吗？

Ryan(02:06:27): 对我在解决类似的问题，因为我们公司本身在做 max 这一块，然后就是工厂的质量管管理那块生产的那一块东西，然后我们本身的分为公司分为两个项目，然后我们简单项目的话，其实针对真的就是表格数据展示加那个按钮，点击这块是比较简单的，还有比较复杂的页面，就是像。

Ryan(02:06:53): 一种比方说我们不知道我不知道怎么说那个类似于物料工序，还有工作流整体的那个复杂工作流的绑定，然后甚至还到那个医疗方面的类似于什么 recipe 的设计，然后他可能深入很多层这块用 AI 方向的话，我还真没有好办法去测试，然后因为，首先我刚刚。错了，然后一个就是针对于像我们在写纯前后端分离那种话，前端代码上面，我们针对于每个可操作的组件去给它一个 ref id，然后这个也是本身 Playwright 它本身的一个或者是谷歌去操作浏览器它自己的一个方案，然后去给每一个组件设置一个标准的 id，这样它比较好去定位它嘛。然后我在。我的想法是我们在现在推，如果我们写前端的话，我们自己在可操作的那个组件上面自己去定义一个，然后这样的话我可以去固化脚本，就是如果我认为我当前脚本是跑通过的，然后在我 id 不变的情况下，它第二次一定是可以通过的，这样就可以去减少当同一个测试用例，在不同的 agent 或者是不同的，AI 模型方向下，它跑出来的结果可能会异常。这样会减少部分异常的情况，然后还有一个就是那种复杂情况，然后用刚刚我说的用图像处理的方式嘛，就是视觉模型方案去做，但是视觉模型方案目前来说确实不快，特别是我用了另外一个 agent 就是刚刚的，我用另外 agent 去分析图片，然后去考虑这个结果，然后再等它返回，然后拿到结果之后，然后再去再继续跑，确实不。

Ryan(02:08:33): 目前确实是个瓶颈，我还没解决，最近也在做这个事。

王艺辉(02:08:39): 这个我再补充一下，你说你是拿的 id 会沉淀一些脚本，那这个你最开始这个脚本，你你通常会让 aiaiai 自己产生吗？还是你会给他演示一遍？

Ryan(02:08:52): 我也当时我做也是两种，一个是如果就是 AI 跑 AI 是自己先去尝试，根据自然语言描述或者是 userjourney 去就是他，一开始我们设想我们 review 过的那个用户故事嘛，然后他根据用户故事去跑，然后去看页面当中的哪些功能。比方说他写的页面里面哪些按钮增删改查或者是搜索查询的那块复杂的搜索查询他会。根据这些样例圈去跑，然后他跑的每一条我都是会荣誉下来的。

王艺辉(02:09:22): OK 其实你你你还是会 review 他的那个东西，就本来其实可能是类似于 GPT 那种纯文字的就是他跑的过程中可能会去看一下，然后会有一些反馈。

Ryan(02:09:28): 对，然后我其实是我自己当时写了一个软件嘛，然后它冗余的是我测试的每一条用类的脚本，还有一个所有的关键帧截图，我当时做的也是挺好玩的，因为他当时我做了一个软软件，可以打关键帧嘛，就是比方说我去监听到每一个，比如说 click 按钮这种 click 事件。

王艺辉(02:09:33): OK OK 明白。

Ryan(02:10:01): type 事件就是 valuechange 事件 input value change 的事件，然后页面当时又重新渲染，就是加载元素了之后，然后有一个关键帧，这样的话，我人去 review 的话，一方面是看我当前的那个脚本，还有一个就是我可以在关键帧的时候直接把图片拿出来看，就是看我当前是否是符合我标准的，然后再然后去强化每一个脚本，说我脚本。下一次一定是可以复用的，然后这样的话我在脚本过程中我的所有的 fake 数据，然后是可以让把让 AI 去把我把脚本里面的一些比较关键节点的那个数据给替换掉的就是没必要每次都跑一样的，或者是复用这个脚本就是跑多个数据，这样的话就会好处理一些。

王艺辉(02:10:43): 你们做的还是很精细化的，我感觉工具有开源的吗？你刚说关键帧。

Ryan(02:10:48): 有，但是不是没有想象中用那么好，就是它 AI 自动化探索的时候还是比较慢，对后面我还是有想法继续再往下做的。

王艺辉(02:10:57): OK 这个我明白，我感觉你还是挺厉害的，有，反正我感觉如果我现在测那种复杂的我确实还没有很好的实践。

Ryan(02:11:09): 复杂相当于就是如果页面不出出现大的变动的情况下，我的后续的脚本是可以去覆盖它，或者是 AI 先覆盖用我的脚本去做到哪一个步骤，然后让他继续去尝试去会有一个比较好的一个点，然后就是起码是一个让 AI 可以知道从哪边开始，或者是哪些场景是可以复用的是这么一个想法，当时。

王艺辉(02:11:34): 我刚刚同学提的，他说他还经常变，可能就更难一点了。

Ryan(02:11:36): 对他经常变，刚刚我们也不也聊到了你即使用视觉模型去做的话，也不是很好处理这种东西。

王艺辉(02:11:45): Ok. 我看这里还有一些问题，我再回答一下，最开始就他已经下线了，他说他问我那个手机上开发那个应用是什么的话就是我就是用的那个 happy 然后这里其实我可以多说一句，后面也会写文章介绍一下这里细节还挺多的，我为了就是让这个东西一直跑，比如说我现在睡在床上，我可以看一下他跑的进度，我然后你可以让那个 cc 去写一个服务器。写个脚本，让这个脚本定时给你那种效果，他可以去切到那个 session 里面给你去发通知，告诉你，他比如说他现在这个任务跑的效果怎么样了？这是一个，还有就是你这个任务，他需要一直跑，但是我们是生产环境嘛，那不可能我自己电脑是不可能一直挂着内网的。那我就需要去单独去申请另外一个服务器，或者是另外一个电脑，然后把这个电脑的24小时开机放到那个公司的内网环境当中。然后你通过这个 happy 就用用那个软件，或者你用其他的 webitem 也都可以。总之能连到你这个服务器上。你这样你才可以说做到一个七乘24小时的开发。

王艺辉(02:12:51): 然后底下我再看看。

秋南Dylan(02:12:55): 小辉刚刚才讲 happycode 的那个问题，就是比如说有界面的，那你在远程你怎么确认就怎么确认这个界面到底做到最后是不是你想要的效果？

王艺辉(02:13:07): 如果是有界面的话，那这种开发方式就不适合了，这也不是万能的，如果有界面的话，不过这个我倒是还有一点经验是我在那个我的服务器上面是开了一个就是我自己是带电脑回来的，然后就是如果是有界面的话，我是在另一个服务器上面，我是开了 docker 里面就是 Aisandbox 从那个 sand box，我是可以看到我的界面的。

Ryan(02:13:13): Hey. 这。

王艺辉(02:13:34): 对可以看到我那个界面就是我如果真的想看的话，我可以通过我的电脑的方式登进去看我手机确实就看不了你手机也可以看。

秋南Dylan(02:13:34): 用远程类似？

Ryan(02:13:41): 我倒是比较有经验的，最近我弄了一个东西，因为之前小龙虾比较火，然后又出来一个后面后续出来一个叫 nano bot 就是迷你的小龙虾，然后我在我的电脑上布了一个 nano bot，然后我可以去远程控制我每一个工作空间里面的 cloud，就相当于我的 nano bot 是一个管理员，他去控制每一个我工作空间里面的 cloud，然后让他用。

秋南Dylan(02:13:42): 拜拜！

Ryan(02:14:06): 那个 tmx 的方式去抓取每一个的结果告诉我当前的所有的 agent 的工作状态是什么，然后我也可以让他进行测试，然后让他把我的桌面截图通过飞书发给我看，这个流程是跑通的。

王艺辉(02:14:18): 你是这么跑通的，可以通过飞书发给你看。

秋南Dylan(02:14:19): 就直直接就在通讯工具了。

Ryan(02:14:21): 对我是这么跑通的。对我是跟我是用飞书去让 boot 去做所有的那个 agent 的管控。然后比方说我让他去那个比方说我一个工作目录底下，然后让他去启动 bm1个 develop 的那个 agent 嘛，然后让 bm develop agent 去实现所有的 story，然后实现完成之后让他去 run test 然后去打开了，让他去通。

Ryan(02:14:49): 通知 cloud 去做测试，然后并且停留在每某一个页面，然后我跟他说，bot 你现在去截图我的桌面给我看，然后他打开到哪种程度了，然后这样的话他就会反馈过来给我看。

秋南Dylan(02:15:01): 那你你是操作 cloud code，然后最后你这个截图其实是用 OpenClaw 它去它的功能去截图吧？

Ryan(02:15:08): 对就是用用用 boot 作为我电脑的一个主管，然后主管去管理每一个工作空间底下的那些 cloud。

秋南Dylan(02:15:20): 明白，小小小辉我这边还有两个问题，就第一个就你刚刚说那 tdd 的一个操作方式就是一般比如说你这边接到需求之后，你是构建 story，然后就直接做解释案例，然后再开发，就你你流流程实际实操下来是怎样的？

王艺辉(02:15:25): 你说。

王艺辉(02:15:40): 对实际的流程是吧，实际流程首先，我接到需求之后，会跟那个业务方一起去拆解一下这个 case，就是我会把这个 case 发给他 review1遍，我会去拆解一下那个 use case，然后把那个 use case 他 review 完没有问题，我就再翻译成 gwt 这种东西。

王艺辉(02:16:03): 翻译成这种用户故事或者用户动线翻译完之后，然后就让 AI 自己去拆解那个就是我平常开发的话，我用的那个 plan 模式还是比较多的，就虽然说是全自动是可以全自动，但是我基本上还是会自己 plan1下，然后 plan 完之后我就是会 review 他的那个测试用例和他给的大概的测试实现的文档，然后后面就让他去后面就让他跑。跑完之后我就重点关注测试偷摸的情况。

秋南Dylan(02:16:31): 其实就是相当于说你写完 story 之后后面再做一步，就是先写测试案例，然后再开发？

王艺辉(02:16:39): 对这个东西是你不一定说，一定是让他就是你这就是 AI 实现的过程中，它不一定是那种红绿循环。就我个人认为，我觉得这个可能红绿循环这个事情可能是在以前 tdd 的时候，因为那个时候可能因为迭代的原因，重构的原因，它这个也是有价值，但是现在这个时候因为你本身写这个代码就很快了，我觉得红绿循环就跟11样可能本身的。

秋南Dylan(02:16:45): 好一点。

王艺辉(02:17:05): 那价值都要被重估一下，但是他让你显现测试这个事情是很有价值的，他会强迫你把这个事情想清楚，就是你不显示，说是你不清楚你你这个需求到底要做到哪些部分，你只是大概清楚而已。

秋南Dylan(02:17:21): 明白 OK 然后第二个问题就是，这可能跟测试的关系没那么大，就是你你你自己在做整个系统的文档的规划的时候，你一般是怎么干的，比如说怎么分文档，怎么管理文档或怎么样把这个文档规划好，确保你的后面的质量。

王艺辉(02:17:39): Ok. 就我这边其实是把就是 AI 所迭代的这个文档都会维护到我的这个代码库里面一起做 git 管理，然后管理的话，基本上我会把这个比如说 MRD PRD 还有这个技术方案，这个东西分层，那个技术方案可能会按版本，如果他 fix 的话会有 fix 的版本就这个东西我会给他分层，让模型就我会告诉他，我会在他那个搞 md 里面给他。

王艺辉(02:18:08): 说这样的一些规则就不让他不要乱写，然后他去找的话，他可以去对应的地方去找，就包括你这个跟模块，就你的 service 模块，你的架构模块，你你的 db 模块，然后不同的模块，也稍微给他分一下。就这样子，还有，其实我现在是没有做那个 hook 的自动触发的，但是我其实是觉得你们确实要做到那个文档和这个同跟变更是同步的话，是可以做一个自己写一个 hook 去让它自动去触发的。

秋南Dylan(02:18:38): 明白说，所以你你你其实还做了跟前面还把那第一这块也做了先做，我明白，那你比如说从像你刚才讲流程，其实你就从正常，比如说这个产品开发我 MRD PRD，然后什么 architect，然后再往下继续拆，像这些文档你还会再拆一个子子层级吗？

王艺辉(02:18:43): MRD，我也会把它落进来，我会手动把它拷过来。

王艺辉(02:19:05): 他 AI 的他一定就是我一定会让他去猜到一个他要去实现的文档就是很简单的需求，就不会稍微中等一点的需求的话，我会让他去猜到一个实现的文档，然后至少让他能猜到，告诉我，现在很关注的是数据结构和这个数据流就对我来说，我关注的更多的是数据结构和数据流，就首先他这个对象得定义正确了。他要理解这个数据流。

王艺辉(02:19:31): 就在整个系统里面，从他这个 F 的接口开始到 db 整个这个数据流是怎么变化的，他至少要能告诉我这个，然后我才认为他这个文档是基本合格。

秋南Dylan(02:19:41): 明明白明白，还有最后一个问题就是对比如说稍微起规模的互联网公司，其实有时候它的需求变化很快，那比如说如果前端经常给你做需求变更，那你，你是怎么跟他们这些就快速的需求变更他们去协作，然后你可能是对于起规模的一个业务，你可能。

王艺辉(02:19:51): 对。

秋南Dylan(02:20:07): 复制某一块，你在做这个事情的时候，跟其他同事是怎么协同的，没有很好的办法！

王艺辉(02:20:08): 对。这个讲道理其实也没有很好的办，我跟你们说个 low 的吧，就是像阿里这边基本上就是比较重要的项目迭代很快的，他会直接给你拉到一个会议室里面强迫你们每天面对面沟通。

秋南Dylan(02:20:19): 那你起来。

王艺辉(02:20:28): 对，然后如果你是这个分隔分楼层分楼的话，或者甚至分园区的话，你这种沟通这个我确实我也没有，我确实也没有特别好的办法。

王艺辉(02:20:39): 就感觉有时候效率确实挺低的，就打电话吧，说实话，直白点，我觉得要么就是面对面的是最快的，没办法面对面就打电话就是能打电话的就不要打字。

秋南Dylan(02:20:52): 了解就还是没有一个很好的办法就是类似于不知道其他人有没有一些经验，比如说原来我们传统做开发，大家反正协同就是定很明确的规则，你改哪里不该改哪里，然后就有人合并那像 AI 这种你代码写这么快，你说一直去 check 这个事情感觉也不太合适，那像大家怎么协作？

王艺辉(02:20:54): 对我确实这个确实我也没有很好，我觉得这可能是管理上会不知道就可能要管理的大佬可以给这些输入。

王艺辉(02:21:24): 你你说你现在提的这个是关于就是多模块开发合作，这个我因为我现在我自己是 o1个项目嘛，然后我会有其他同学一起开发这个我可能还是去拆模块吧，我不太清楚，就是我可能就是会给每个人分分分一块，然后让他去开发那个，然后我会总体来大概 review1下他的东西。

秋南Dylan(02:21:29): 对都多人都能看的协作。

秋南Dylan(02:21:49): 明白，那其实还是传统开发的协作模式，就肯定还是需要有人去背锅！

王艺辉(02:21:53): 还是传统的，对可以也可以这么理解吧，就本质上来说，AI 它再强，它本身没办法负责这个东西，你你你可以说我一个小时就把代码写完了，我一天都不干活了，这个反正公司现在是这样子，那你给了你这样的条件，那你就你要是真干完了，你就躺着嘛。这个东西如果真出问题了，你该修线上 bug 还是得还得是你。

秋南Dylan(02:22:01): 对。

Ryan(02:22:18): 这个这块其实我这边也是有一定探索的，就是因为我们当时我们这个项目也算比较一个传统的项目，然后我们这个方案就是因为因为我给我们那个公司的那一套东西做了一个比较自动化的流程，所有的代码出错率大概在百分之八九十的，他们是可以直接用的，然后我们这种比较拆的。

秋南Dylan(02:22:26): 完了。

Ryan(02:22:44): 模块的先是根据功能模块拆，然后后面先是拆了功能模块之后，然后再给每一个人进行，甚至去页面方面的上面去拆，然后页面方面的话，我们会事先考虑到，比方说我哪些组件是可以通用的，或者是哪些我们直接用框架类的东西，甚至我们因为我们是有平台组嘛，我是把所有的组件都定义好的说你能不尽量去。使用新组件就不使用新组件，这样便于后面维护，然后这样的话，他每个人用那套工作开发流的情况下去做，会先去输出一个需求文档，然后需求文档里面会去说我用到了当前业务当中的哪些，我平台组的一些模型，或者就是那个领域模型嘛，甚至是那个基础的模型，需求分析是什么东西用户。刚刚说的那个 dwt 或者是甚至是 user journey，然后都是有的。这样的话它会先输出一个叫初始化文档，就相当于是 PRD 文档。然后这样的话，我们本身的每个组的负责人就会去 review 这个文档就是先 review，我们现在是先不 review 代码了，先 review 去需求的文档 PRD 文档，然后是确定。

Ryan(02:23:59): 我们说负责人和那个产品经理或者是售前，我认为我做的东西都是对的，因为 AI 去分析所有模块的需求，文档是很快的，然后人 review 了文档之后就相当于确认了蓝图嘛。然后我们再去每个人做负责的那一块，就是去控制我的 agent 嘛，就是每一个 agent 的负责人去让他 agent 去做输出，然后保证输出完成之后，然后保证测试之后，然后再集中进行最后的一个测试，或者是集成测试之类的东西。

王艺辉(02:24:31): 你们还挺先进的，已经 review 到了，确实是这样子的。

Ryan(02:24:38): 对当时也是想你 AI 输出的确实太快了，你这样人去看代码看，最终结果实在太慢了，不如先去 review 文档这种东西，保证说我，你认为你 AI 已经充分理解了，或者是针对于这个需求已经充分理解了，我只要保证最后结果是对的就好。

王艺辉(02:24:59): 我接着再回答一下聊天里面的问题，然后三色堇这个同学说，他让我希望我能介绍一下这个前后端全站的经验是这样子，我本身是写 java 出身的。然后我因为要做 agent 就是我就是写了 python 然后又因为写了 python 之后，我现在同时负责 B 端跟 C 端的项目，然后 C 端的是有专门的前端去负责的，但是 B 端是。需要有一个内部的平台，就是跟 C 端一样的这个 agent 的这个效果也要来，在这个 B 端也能看到，然后也可以做一些实验，这个 B 端的平台，就确实其实有前端同学帮我去做的，但是我就是前端的是外包同学，我觉得他做太慢了，然后就，就我就直接上手去自己去做了，然后这个经验的话，其实我个人也不是就学前端出身。也是写 java，然后又转 python，然后又转，今天又写这个 react，这个东西本身就是我前端代码，可以说我一行都没写过，然后我就是承让 AI 就去，就我不懂的就问他就这个东西，我感觉就是一个唯手熟尔的过程，就反正目前能跑就代码能跑，然后写完之后，我会去就那个代码，我基本上会把整个框框架写完之后就是功能上就是我保证是跟后端的功能交互。

王艺辉(02:26:16): 上没有问题，但是他比如说前面有些样式，比如说我现在要实现一个玻璃态，或者我要去改变某个什么什么界面色，假如说这种比较细节的这种事情，我可能就不会去管了，我这个事情我会去交给我的那个前端的这个外包同学，然后去让他去继续去跟进。

王艺辉(02:26:32): 我现在是这样子的，但是具体就开发里面其实我感觉就我感觉那个前端它跟后端其实也差不多，就本质上还是去关注这个数据流，就前端可能数据流还相对来说比较简单一点，它可能复杂的是像我现在用 reactreact，可能是说它有些 state state 的全局变量的传递会复杂，其实跟后端相比也没有那么复杂，就本质上还是把这些。数据流给你理清楚，然后数据结构给他跟后端能11对应上，我个人就感觉还好，这个可能是一点点小经验，然后看还有没有其他问题。

王艺辉(02:27:12): 小灰的主页网址，这个网址就是小灰点酷，我稍微自己打个广告，但是我其实也不怎么更新，就随便看看。然后对有人已经有人发了 waterwater 这个同学已经发了，然后懒惰是进步之源好，然后问题可能就回答完了，大家看还有没有什么其他问题不？

马驰(02:27:40): 我认为没有了，不过整个课程分享我觉得我们累积了很多未解决的问题，可能需要后续再去研究。

王艺辉(02:27:49): 的相互讨论才能学到更多给我一个苹果，大家都有苹果。

马驰(02:27:55): 是现在每个人给每个人苹果，每个人都会有 N 个苹果。P. 也还有一点就是我看到其实是我软件工程这一块，我们中国工程其实一直落在后面，就是比如说云计算，或者是说 tdd 这些中国的在中国推广都比较落后，但是现在 arcoding 其实把全世界的，软件工程师都拉到同一个起跑线上来，从我本人的感觉来说，其实就是在软件工程，这我们现在这些未解决的问题，其实也是全世界未解决的问题。

王艺辉(02:28:00): 很好！

马驰(02:28:29): 我们其实是在探索软件工程，整个行业的无人区，这里面机会真的非常大。

王艺辉(02:28:36): 这里再扯一点，稍稍微再扯一点，未来的部分就是我其实现在公司里面，包括这个组织变革感觉的变化都挺快的，就我最开始提到的是那个像必学那个新闻，大家应该看到了转都转硬件的工程师，现在企业内部那个包括我们上面的老板一些开会，反正我能感觉到的也是大家也挺迷茫的，就是虽然觉得趋势都是这个什么工种融合，但是你真的落实到组织变革上，也不可能啪一下，就把大家都打成一个什么 tp。

王艺辉(02:29:07): 团队让每个人都干，所有人干也不太现实，这个感觉确实还有点意思，就是想看看后面到底怎么发展。

马驰(02:29:16): 我是不太同意，说每个人都要干所有股东，我觉得他扯。

王艺辉(02:29:21): 他干所有工作不是说你真的去 O 所有工作，但是说你每个人是可以互为 backup 就是类似于说你就是你你你尤其是对于像现在这个业务来说，每个人是肯定是 o1个业务的，比如说你你负责订单，你负责交易，你负责这个什么成交之类的库存之类的，这每个人的业务肯定是去 O 的，他是不能被替换的，但是他。这个代码你比如说你你你作为一个前端，你是不一定受限于你这个前端的边界后端，假如说真的，现在有个需求，你自己是可以去承接的，就类似于。

马驰(02:29:57): 在这里面我也有些探探索，我刚组建了我们一个三人团队，我之前写过文章分享吧，就是一个负责产品，一个负责质量，一个负责实施，我觉得是比比如说让我一个人去承担所有工作要好很多好，非常多，可以这么说，就是，你看我现在跟你大量讨论这种测试，我本人扮演。

leo(02:30:00): 我说一下。

马驰(02:30:25): 这两个角色，一个是测试去控制质量，一个是快速交付的产品，这两个是有冲突的，我现在引入另外一个同事过来让他去跟我做对抗性，这种开发就是说我去交付快速交付代码，他去控制质量，这样的话其实两个人的心智负担都会轻一点，因为你只要聚聚焦一个目标嘛，对，实践下来也是。

王艺辉(02:30:35): Mm. Hm. 

马驰(02:30:50): 会更愉快一些，我就不用自己去挣扎了，老是要换换思维模式，一会说我要做的快，一会说我要做的好。但是目目前我也只有比如说几天的经验，我觉得可能过个两三个礼拜，我应该会摸索到一个比较比比比较就怎么说，可能够摸索出一个比较通用的方式就大家质量控制怎么跟 technologyowner 怎么协作。

王艺辉(02:31:29): 我是觉得这种会带来一点沟通成本，他不是说就真的全替代了，就是你还是会有人去真正为线上这个东西负责就质量是最后一道关卡嘛。

leo(02:31:31): 还有我。

王艺辉(02:31:42): 但是他可能在开发过程当中，他是我个人觉得是会全占的，然后这个其实还有一种说法叫做全牛就 firststream first stack，就比那个更比 first stack 更宽泛一点。全牛 first stream 的说法。

马驰(02:31:55): 对，那你爹你说！

leo(02:31:57): 一下我的看法就几个，第一个就是必选那个说法，我觉得这个话只说了一半，因为它是。他是老板，他提了这个 AI 架构师工作的话，其实有个潜台词，我认为就是他都会通过。淘汰去选择适合做件事的型的人，不是说他要将所有现在的人转成什么 AI 架构师，而是说。一些不适合做这种从头到尾在一起的这种人就会被直接被淘汰掉，所以干掉，因为其实管理一个很经典，一个东西就是说。

leo(02:32:43): 我其实淘汰人是快过，我要培养一些不适合的人，所以我觉得第一个是会淘汰掉一大部分人，这是第一个，不像我这边是国企嘛，所以其实我们比你们互联网这更惨一件事情就是说我没有机会淘汰我下面的人，我只能还是要找点活给他干，又不能让他太太太失落。不然他还会去投诉你这是第说的第一点，然后第二点的话就是说，我认为可能一个人就是这样讲吧，可能。只是讨论了就是马工三个人可能是因为架构所谓的 rules，这些东西可能不太成熟的做法就是在我个人认知里面，全牛这件事情是有几个全牛是在企业里面。

leo(02:33:42): 去做这些 rules 就那几个大流，其实是把你整个流程上面怎么做，企业架构怎么做，刚才是还是谁讲他平台团队的嘛，其实他已经他就是到底这件事情该怎么做，其实不是这个 owner 这个人去决定的，而是说这种全流跟架构团队甚至银行。

leo(02:34:08): 刚刚坦率来讲我一件很老旧的事情也不是很老旧，就是银行大的银行全部有统一开发框架，其实所有同学在这统一方框架上面 crud 你没有任何的。的发挥的空间的，你什么高性能加密日志怎么打，那个部署到底是两地三中心全活还是什么无状态，还是怎么样，全部都是你都没有选择权的，其实你只是最后一个 lead boy 去执行，所以其实 AI 时代其实更也是一样的，就是说这个总体的入市在 CMD 也好。选MD 也应该带有什么框架，复用什么框架，其实都是有少数的全都已经定了，那去到每一个应用的人来讲的话，我个人认为可能。也真的是一个人搞定就算了，就是有几个好处，第一个减少摩擦，然后第二个这个人责任全担你快也要质量也要反正有事我就找你麻烦，然后第三个反正你又遵循所有的框架，那这个是最快的，就用我最少数的人去把责任聚焦了，把架构聚焦了！

马驰(02:35:01): Than. 

leo(02:35:23): 然后我觉得可能以后会是这个样子。

王艺辉(02:35:28): 我挺认同的。

Ryan(02:35:30): 对这个东西，这个观点其实我还是比较有想法的，因为当时我不记得马工还记不记得我就一直在跟你提说我们后面的开发，特别是如果不涉及到特别那种个性化的开发的话，一定是类似于低代码的那种感觉，就是我所有的框架都是固定死的 AI 去跑，一定是按照我这个。

Ryan(02:35:56): 框架规则去输出代码，那么他输出的代码一定就是标准的代码，然后特别是我们之前比较经典的那种有低代码平台公司的团队，他每一个人其实都是一个前后端模糊的一个状态，他负责的就是他对应的刚刚的需求分析模块分配到你每一个页面，那么你们你负责十个页面，那十个页面的负责人就是你，你不论你用手敲的方式。还是用 icode次性输出90%代码的方式去做，那么你就针对于你需要对于你这个需求去进行负责，所以这种情况下，前后端的那个工程师真的就是很模糊了。但是如果是 TOC 的情况下，我觉得还是需要思考了，就是 AI 输出的东西到底是不是 C 端用户想要的东西。不再探讨我就没有那么多经验了。

leo(02:36:49): 对我觉得你说。

马驰(02:36:50): 一下就是我觉得前半后到这个合一，没有什么疑问，因为从从我的维度看，这都是实施，就是我的三人团队里面这都是 technology 要做的事情，但是我特意想要把质量控制分出来，是因为质量控制它的目标跟你，比如说前端，后端和任何程序实施的目标是不一样的目标其实是要减缓你的。那监管里说要以实际换取质量，但是你你比如说如果你不论是前端还是说你写任何小程序的时候，写 APP，你的目标都是很简单，就是说你最少的迭代要快速完成任务，但是你很可能就牺牲质量。这里，所以我是觉得就是质量控制很可能会成为一个单独的角色。因为传统软件工程其实也有吧，但是传统里面不会说我给你每一个程序员配一个 qc，但是现在我觉得这是完全可能就是你一个程序员11或者一个架构师，你会带着一堆，那我就会配一个 qc 带着一堆跟你对抗。那你从管理。

马驰(02:38:01): 学的角度来看我让这个人去快速交付东西，但是我还得安排一个人去确保他交付的东西是我想要的东西。因为你我们也可以看到，不论是还是人，有时候都会弄虚作假，这个 bug 过不了，我就把这个测试用例给删掉，明明是没达到要求，硬说是完成的任务达达到了要求你你你当然你可以说我要找一个有责任心的 O 去做这种事你就要对抗人性的嘛，你对抗人性，你还不如说你用组织上就是让他让另外一个角色去制衡。这是我认为一定不能说全部交给一个人，另外从你从另外一个角度看，如果你全部交给一个人，你回头他建立一大堆，这种东西完全是他个性化的你你到时候接手的话也有困难。

leo(02:38:54): 我补一下说像我前东家就是很多质量你都跑不出什么。问题来了，因为像我前东家大概5000个开发吧，其实他用的统一开发框架就是大概30多个人团队写出来的，那大概花了三年时间吧，最后也不是最后吧，到我离开的时候大概是21年的时候已经是。

leo(02:39:28): 网点的人员都可以通过统一开发框架去写程序的，所以再换一个角度来讲，就是 AI 写的更没有问题，所以我觉得这个质量的话其实不会。就土 C 可能是另外一回事，因为刚才说土 cagent 出来的东西合合适合适不合适，那是其实坦率来讲，其实都不是，我认为都不是一个什么程序的事情，其实在我们那边，就我们金融业这个其实已经算是内容安全的事情，就你讲的有没有风险问题的事情，我回到这个程序这件事情来讲的话，我连网点的人。在一个框架里面写出来的质量我都敢保证，更何况是 AI，这是我的第一个观点。然后第二个观点就是说，程序员想实施想做的快的这件事情，其实真的是就都足够快了，比如说大家现在一网都录都能录出来了。

leo(02:40:25): 这个有需要到半小时就上线吗？这个可能就跨一件事情以后其实都根本就不是一个主要的矛盾，可能反而是慢，质量是一个主要矛盾，说以前因为足够慢，所以我要快。但是如果我足够快的话，我还要不要这么快，可能主要矛盾就不是我要多快，而是说我可能要多稳。甚至刚才那个刚才的同学说的那个运营的事情，就我程序的逻辑可能就在于说我怎么把可观测性做好，我怎么把可运营这件事情做好，而不是说我要做的多。

leo(02:41:06): 快，所以我觉得站在我金融业吧，站在我的理解的角度来讲的话，其实快已经不是这个 AI 时代。必须的事情，甚至在某种程度上，昨天薛老师的分享的快到极致，其实在一个真的公司里面，真的你你你的太快的话，真的有没有必要，但我觉得更重要的是他前面那半句话重到极致，就是说你的体验要足够好，而且你的体验是能够通过你这个用户的这些反馈，或者说你的一些埋点数据能够。自迭代的让你这个程序变得更好，我觉得这个可能还是以后软件有生命力或怎么样地方就是像苹果这样，它其实不是靠快来赢来用的，说它质量拿说我难听点说句它的功能都可能不如华强北的花俏。但他的就是不卡，然后他就是这样的稳定，然后这个他就是要体验，所以我觉得这个后面可能这个人的这个对程序员的调性跟目标可能以后都不一样，但是可能什么时候会发生，我不知道，但我个人感觉就是一年后可能程序员的目标是把。

leo(02:42:38): 这个融合上一个大的逻辑就是说程序员以前只管快，当他走向产品的话，是希望这个产品有生命力好，运营好更好的 capture 到用户的心声，而且快速的。反哺到这个软件上，所以我觉得快跟质量可能是我们现在要聊的事情，但不一定是我们未来所需要的特质。我讲完。

Ryan(02:43:04): OK 这个其实我你是因为你是在金融行业嘛，你们的是比较固化的一个标准嘛，然后其实我做那个传统型行业的那个工程这块东西的话，我们其实也是积累了好多年的，然后积累了一套低代码的这个东西，然后我们积累这套东西，为了让实施过程中那些我们实施软件工程师，他的成本足够低，也就是说我们招一个。

Ryan(02:43:30): 一个类似于实习生，他就可以去实施整个工厂项目就是成本足够低，那然后我这边给他提高的效率就是更给他加速，就是我用 AI 本身 AI，你说他的技术水平就已经超过这些实习生了，那我把他所有的标准给他固化好，然后把他的所有的 skills 给他写完之后，他去跑整个工作流出来的结果就是我，他指定想要的东西，甚至。说 AI 出了这个标准，我给完标准之后，他写出来的东西比实习生写出来的东西更好，因为他按照同样的标准来写，你刚刚也说了，我们会有一个叫，有一个 owner 的那个心理的状态，就是同样是一套标准的东西，一个人来写，他想的比较多，他做的优化比较多，就是页面上的一些交互细节上面的他考虑比较多，那么他做出来的东西一定比。说，我就完成 cuid 我拖一个按钮往上去，然后反正功能实现了就 OK 嘛，这个肯定会是更好，但是确实这种 TOB 端的东西和 TOC 端的东西还是不一样。我觉得后边的话，你说我们程序员的思想到底应该往那边转变，还是说我们程序员还是依然就保证 AI 输出的东西是 OK 的，要有专门另外一个东西去保证。

Ryan(02:44:45): 质量足够好，就像马工一样，我需要有一个对抗的角色在存在，我觉得还得是得去看去探索，去看后面我们软件到底会发展到一到什么程度，就是我们现在还是以我们之前的视角来看，就是有一个页面，或者是有一个交互这个东西，但是后边实际上到底发展到什么程度，还真不太好说了。

秋南Dylan(02:45:08): 有没有可能有一种情况就是刚才聊到其实要做测试嘛，那其实你看，比如说最近这两天阿里发千万的时候一堆 bug，那对于他们来讲，或者说对于后面，比如说都是做 C 端的软件，你把用户当成测试就行了嘛，你东西先出去完有问题你马上改，因为你改很快嘛。

Ryan(02:45:26): Than. 呵，对就对。

秋南Dylan(02:45:31): 就这个是？

马驰(02:45:31): He. 

王艺辉(02:45:32): 那行是反面教材，它会消耗用户信任的。

leo(02:45:36): 就怕看看谁想死就这样做了，因为这个新时代来说，抛弃一件事情太容易了，一爽不对就切换另外一个竞品说，我相信先问那件事情，不知道有多少人在内部背锅了。

秋南Dylan(02:45:47): 回国的，那我举的是一个例子，肯定你后面不能这么去做，但是就是比如说你后面，比如说因为产品的就写代码，这个效率足够高了，那你找这个产品不要有太大的问题，不要太大，比如说类似像千万，你压根你的业务就没跑通，那如果有些小的细节性的问题，比如说这个页面可能跳的慢一点，那没关系，你出去完用户有反馈回来，你再改就行了。

秋南Dylan(02:46:23): 不一定非得在出去的时候把质量做的非常严格再出去。

leo(02:46:28): 我觉得反而不一定，因为说白了，其实我认为在 ai coding 的写出来的东西，我并不觉得它会比我们现在的人写的质量差的。我觉得这是第一个。所以而且第二个 AI 这件事情我们虽然说 coding，但其实 AI 是在至少在我们单位是在架构治理是在 coding 是在测试是在运维，甚至到后面的 qc 就是我们的所谓的指控这方面。全面拉上去的，所以其实靠对我先说完就是说没有什么一样不一样的，因为所有的软件开发都是从架构开始，然后出设计，其实我们也写需求说明书，你也写需求说明书，其实流程没有不一样的说我以前说我们金融的坦率讲，就是我们金融的钱可能稍微多一点，我们质量可能我说。

秋南Dylan(02:47:06): 你你，你是你你是金融行业嘛，金融系统嘛，然后那可能还不太一样。

leo(02:47:38): 重重一点，以前你们相对小的话，你没有钱投一件事情，在 AI 时代我难听的说句。你的那个非功能性需求，然后你拿着蚂蚁的那个军规是吧，你拿着银行的一个东西，你作为 rooms 放到 AI 里面，他自然就把你的质量从从你的本来源那里30分一把就给你拉到80分了。所以你其实就说这一块的话，你的质量砰砰砰的就会往上涨的。

leo(02:48:12): 所以我觉得我想表达的是说，当每一个就站在我的角度来看12345全生命周期流程其实 ai holding 这一块领域，在整个软件生命周期里面其实占不到20%。你想，其实 AI 在剩下的80%的地方在提效，所以这个质量我是绝对不相信 AI 写出来的东西就。除非没想清楚，就是纯 Y 扣的一把来，否则的话只要正常一点的话，它的质量一定是比现在你乱写写的好的。所以你现在像 BM 是吧，像 BM 的话，可能给你各种交互这样那样的东西是吧，但是你4.6，现在5.3出来明显他好像又好一点。然后你的 ros 只要你有某位大哥或者怎么样，把各个比如说银行甚至说军工，这些 rooms 全部贡献出来？那它的质量一定是比你自己，因为你见都没见过的话，你质量肯定差嘛，但是你你你用了这些 root 你质量一定是往上涨，所以不会说。你跑出来的就拿用户测，而且我们其实在聊到很多事情说以前你不会写么，以前你可能不会写单元测试，那你你现在都有这些东西可以低成本做了，你怎么可能写的比以前更差？所以我觉得我是可能废话有点多，就我是这样表达，就是说质量一定不会比以前差的，然后说。

Ryan(02:49:55): OK 今天我们聊端到端测试，其实就是为了保证质量嘛，我觉得质量也不会太差的，特别是有 AI 引进过以后所有人的效率工作效率其实都是提升的嘛，各方面的提升，既然都提升了输出变快了，那我们着重去让他去更多的去考虑质量问题的话，我觉得质量问题也不会特别差，是这样说。只不过我们在考虑怎么样，用更好的方式去保证它在高速输出的情况下，也能做高速的质量去管控马公司虽然说我去延缓了整体的说我现在开发质量速度，你去做了一个对抗去减缓速度，其实你更好的想法是在减缓的同时，怎么样能让一个专门的质量角色。用 aaai 的方式多 a 进的方式去对抗形象下，让质量更好的又得到保证，并且能让整体的速度得到提升。你并不是为了延缓它，而是让它在以延缓的方式去保证它质量是输出的是你想要的那个东西，其实整体的还是要提速。

马驰(02:51:06): 是思路是速度已经不是瓶颈了，速度已经远超于其他指标了，那我牺牲一点速度能换取质量是完全可行的，因为我即使牺牲了之后，我的速度还是传统古法编程的十倍。

Ryan(02:51:10): 对。

马驰(02:51:21): P.。

Ryan(02:51:24): 行，还有其他人要讨论吗？今天还是聊这么多说后面我们找个机会继续新话题，接着聊。

马驰(02:51:36): 我觉得我们至少还可以接好几个话题是我就小辉回答了很多问题，还有很多，我们又提出了很多新的问题。也许我们可以，比如说三个月之后，小辉再来分享一下，然后小辉再看一下三个月之前我为什么没想到就是我上个月之前怎么这么笨，连这个都没想到。

王艺辉(02:51:56): 可以。

马驰(02:52:03): 我现在 AI 时代就是这样子，你，你过三个月之后你再看三个月之前的就是太原始的。

Ryan(02:52:04): 对。

王艺辉(02:52:11): 三个月之前我看 gpn6能不能出来，到时候可能飞跃。

马驰(02:52:15): 是三个月之后，我们现在讨论的问题都无关紧要了，人家大模型已经解决了。

leo(02:52:18): 对我觉得都无关紧要了，在三个月之后都无关紧要，很多事情对说真的，这些测试坦率来讲就是在。

Ryan(02:52:24): 对。

leo(02:52:30): 你说测试是保质量的一点吗？最重要的吗？是但是对但前面的你的架构，刚才已经提到了你的统一开发框架，在那个 PRD 里面已经决定了你的质量大概长什么样子的。然后还有的话就是你的 PRD 的 review，你 PRD 的那个预跑。你你这个东西就很多东西都完全变了。

马驰(02:52:35): 对这样的。

leo(02:52:57): 可能后面说质量去怎么保证可能比测试怎么保证更重要，我觉得？

Ryan(02:53:09): 很难去分析的，就像我们之前去跑跑Cloud，然后我们用做一整套 B，然后作为一个工作去处理，然后结果4.6出来的话，昨天不都已经有 team 的模式了吗？我靠他自己内置了，就是整个的 B 的内容思想的方式，然后整个的流程帮你做完了，甚至都 reviewtesting 完了之后的把结果再输出给你。你说三个月之后模型会发展到什么程度，还真的不好猜测。

马驰(02:53:38): 那我们就先定个三个月之后我们再来回头讨论一下问题，然后讨论之前我们先把今天的，比如说大大概再读一下。

马驰(02:53:51): 研究会发现有些东西完全变了，已经没有讨论价值了，但是有些东西可能是大模型本身无法解决的，那是真正的工程问题。

Ryan(02:54:01): 可以的。那今天我看一下聊天里面还有什么内容？

王艺辉(02:54:07): 最后还有一个，我看有个同学会这样提了一个问题，他说小公司用 AI 落地步骤怎么样，对我觉得就是你说的先写测试用例，然后自动化这个其实 AI 也帮你写就是就可能我们更多的是关注他这个就我的看法，关注他的这个用户动线这个结果的交付的部分，后面的部分就是尽量就 AI 去完成就好了。

Ryan(02:54:35): 小公司感觉还是分业务吧，其实如果是 web 端的业务是可以让 AI 去自动化去探索的，就现在也有一，另外一个开源的一个社区在做这个事儿，就是也是跟我的思想是类似的就是你去给他一个 URL，然后他去相当于是递归深度探索你每一个当前的项目里面的所有的功能点，就相当于是一个。

Ryan(02:55:01): 相当于是必卖的去看综艺项目一样，他把你所有的功能都列出来，然后输出成测试脚本，然后跑了每一个测试脚本之后，然后最终输出成测试报告可以解决一部分问题，然后我感觉还是最终的想法就是去积累下来 AI 去帮你做的每一个测试用例，还有自动化测试的 API 的 demo，每一次能保证你的测试用例。

Ryan(02:55:26): 能被跑一遍，现在跑所有的回归测试之前用人来跑很慢，之前其实也有冒烟测试去保证自动化的，但是现在用 AI 的话，这些东西都不成问题吧，就是它成本已经相当于就是基本上等于没有了你成本其实就是可以忽略不计的，总比人会便宜很多。

Ryan(02:55:52): 马工，你看今天聊这么多差不多吗？

马驰(02:55:52): 我就是一点就三个月之后我会再找你们，我们再重新看一下现在的问题，我忽然觉得这是一个非常有意义的阶段性总结，就是我个人感觉就是我们其实已经走在前沿了，无人区的我们探讨的问题是业界没有人探讨的问题。

Ryan(02:56:04): 开源社区？

马驰(02:56:17): P. 三个月之后再看一下这些问题，如果说还没有得到回答的话，也可能这个问题就是最重要的问题。对这个问题，那我们如果继续研究的话，对得上刚才这位老哥叫我们的大大脑，现在你说大脑我心里很虚弱。

Ryan(02:56:26): 对。

Ryan(02:56:38): 没有你走在前面的都叫大佬嘛，这个没有必要去这个问题，那个辉相您在我们那个群里面吗？因为因为我现在之前我看到了他跟我研究的方向是类似的，然后我还有记录，但是我现在一时半会的我也瞬间想不起来，他到底是哪一个了？在群里，我可以找到之后我发在群里面给您看一下。

Ryan(02:57:07): 怎么加评委马工先加你。

马驰(02:57:10): 老哥你开个摄像头，你说个话，你这都不知道你长啥样，你要的。P. 哼你你会找找个渠道联系 rain 吧，那我觉得我们今天是差不多了。

Ryan(02:57:38): 行差不多，然后我这边我给他留个联系方式，然后我这边跟他分专门单独分享给他吧，然后今天大概就这些行吗？

马驰(02:57:50): 感谢小辉，感谢艾瑞！

Quanzhi Fu(02:57:51): 感谢感谢瑞，感谢小辉！

Ryan(02:57:54): 好。

秋南Dylan(02:57:55): Hey. 好拜拜。

王艺辉(02:57:56): 没有跟大家交流。

马驰(02:57:58): 好拜拜，谢谢！